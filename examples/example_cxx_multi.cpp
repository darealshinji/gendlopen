// Do not edit this file!
// It was created by gendlopen on Wed Mar 27 18:56:44 2024 CET
// using the following flags:

// --format=C++ --separate -i helloworld.txt -f -o example_cxx_multi.hpp
// --default-library LIBNAME(helloworld,0) --include
// QUOTE_STRING(helloworld.h) -DGDO_ENABLE_AUTOLOAD -DGDO_WRAP_FUNCTIONS

/**
 Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 SPDX-License-Identifier: MIT
 Copyright (c) 2023-2024 Carsten Janssen

 Permission is hereby  granted, free of charge, to any  person obtaining a copy
 of this software and associated  documentation files (the "Software"), to deal
 in the Software  without restriction, including without  limitation the rights
 to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
 copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
 IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
 FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
 AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
 LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
**/

#include "example_cxx_multi.hpp"


gdo::message_callback_t gdo::dl::m_message_callback = nullptr;
gdo::dl::handle_t gdo::dl::m_handle = nullptr;

gdo::dl::fptr_helloworld_init_t gdo::dl::m_ptr_helloworld_init = nullptr;
gdo::dl::fptr_helloworld_hello_t gdo::dl::m_ptr_helloworld_hello = nullptr;
gdo::dl::fptr_helloworld_hello2_t gdo::dl::m_ptr_helloworld_hello2 = nullptr;
gdo::dl::fptr_helloworld_release_t gdo::dl::m_ptr_helloworld_release = nullptr;
helloworld_cb_t *gdo::dl::m_ptr_helloworld_callback = nullptr;

bool gdo::dl::m_loaded_helloworld_init = false;
bool gdo::dl::m_loaded_helloworld_hello = false;
bool gdo::dl::m_loaded_helloworld_hello2 = false;
bool gdo::dl::m_loaded_helloworld_release = false;
bool gdo::dl::m_loaded_helloworld_callback = false;


#if defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)

namespace /* anonymous */
{
    void error_exit(const char *msg)
    {
        auto cb = gdo::dl::message_callback();

        if (cb) {
            cb(msg);
        } else {
            std::cerr << msg << std::endl;
        }

        std::exit(1);
    }
} /* anonymous namespace */

/* function wrappers */

GDO_VISIBILITY helloworld *helloworld_init(void) {
    if (!gdo::dl::m_loaded_helloworld_init) {
        error_exit( "error: symbol `helloworld_init' was not loaded");
    }
    return gdo::dl::m_ptr_helloworld_init();
}

GDO_VISIBILITY void helloworld_hello(helloworld *hw) {
    if (!gdo::dl::m_loaded_helloworld_hello) {
        error_exit( "error: symbol `helloworld_hello' was not loaded");
    }
    gdo::dl::m_ptr_helloworld_hello(hw);
}

GDO_VISIBILITY void helloworld_hello2(helloworld *hw, void (*helloworld_cb)(const char *)) {
    if (!gdo::dl::m_loaded_helloworld_hello2) {
        error_exit( "error: symbol `helloworld_hello2' was not loaded");
    }
    gdo::dl::m_ptr_helloworld_hello2(hw, helloworld_cb);
}

GDO_VISIBILITY void helloworld_release(helloworld *hw) {
    if (!gdo::dl::m_loaded_helloworld_release) {
        error_exit( "error: symbol `helloworld_release' was not loaded");
    }
    gdo::dl::m_ptr_helloworld_release(hw);
}

#elif defined(GDO_ENABLE_AUTOLOAD)

namespace /* anonymous */
{
    auto al = gdo::dl(GDO_DEFAULT_LIB);

    void error_exit(const char *s1, const char *s2, const char *s3, const std::string &s4)
    {
        auto cb = gdo::dl::message_callback();

        if (cb) {
            std::string msg = s1 + (s2 + (s3 + s4));
            cb(msg.c_str());
        } else {
            std::cerr << s1 << s2 << s3 << s4 << std::endl;
        }

        std::exit(1);
    }

    /* used internally by wrapper functions, symbol is never NULL */
    void quick_load(const char *symbol)
    {
        if (!al.load()) {
            error_exit("error loading library `", GDO_DEFAULT_LIB, "':\n", al.error());
        }

#ifdef GDO_DELAYLOAD
        if (!al.load_symbol(symbol))
#else
        if (!al.load_symbols())
#endif
        {
            error_exit("error in auto-loading wrapper function "
                "`gdo::autoload::", symbol, "': ", al.error());
        }
    }
} /* anonymous namespace */

/* autoload function wrappers */

GDO_VISIBILITY helloworld *helloworld_init(void) {
    quick_load("helloworld_init");
    return gdo::dl::m_ptr_helloworld_init();
}

GDO_VISIBILITY void helloworld_hello(helloworld *hw) {
    quick_load("helloworld_hello");
    gdo::dl::m_ptr_helloworld_hello(hw);
}

GDO_VISIBILITY void helloworld_hello2(helloworld *hw, void (*helloworld_cb)(const char *)) {
    quick_load("helloworld_hello2");
    gdo::dl::m_ptr_helloworld_hello2(hw, helloworld_cb);
}

GDO_VISIBILITY void helloworld_release(helloworld *hw) {
    quick_load("helloworld_release");
    gdo::dl::m_ptr_helloworld_release(hw);
}

#endif //GDO_ENABLE_AUTOLOAD
