/**
 Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 SPDX-License-Identifier: MIT
 Copyright (c) 2023-2025 Carsten Janssen

 Permission is hereby  granted, free of charge, to any  person obtaining a copy
 of this software and associated  documentation files (the "Software"), to deal
 in the Software  without restriction, including without  limitation the rights
 to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
 copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
 IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
 FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
 AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
 LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
**/

/**
 * Generate the output data (STDOUT or save to file).
 */

#ifdef __MINGW32__
# include <stdlib.h>
# include <wchar.h>
#endif
#include <stdio.h>
#include <algorithm>
#include <ctime>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include "cio_ofstream.hpp"
#include "gendlopen.hpp"
#include "open_file.hpp"
#include "types.hpp"
#include "utils.hpp"


namespace fs = std::filesystem;


namespace /* anonymous */
{

#ifdef __MINGW32__

/**
 * convert from string to wstring;
 * this is required because on MinGW std::filesystem will throw an exception
 * if the string contains non-ASCII characters (this doesn't happend with MSVC)
 */

wchar_t *char_to_wchar(const char *str)
{
    size_t len, n;
    wchar_t *buf;

    if (!str || ::mbstowcs_s(&len, NULL, 0, str, 0) != 0 || len == 0) {
        return nullptr;
    }

    buf = new wchar_t[(len + 1) * sizeof(wchar_t)];
    if (!buf) return nullptr;

    if (::mbstowcs_s(&n, buf, len+1, str, len) != 0 || n == 0) {
        delete[] buf;
        return nullptr;
    }

    buf[len] = L'\0';
    return buf;
}

std::wstring convert_filename(const std::string &str)
{
    wchar_t *buf = char_to_wchar(str.c_str());

    if (!buf) {
        std::cerr << "error: mbstowcs_s(): failed to convert string to wide characters: "
            << str << std::endl;
        std::abort();
    }

    std::wstring ws = buf;
    delete[] buf;

    return ws;
}

#define CONVERT_FILENAME(x) convert_filename(x)

#else

/* dummy */
#define CONVERT_FILENAME(x) x

#endif // __MINGW32__


/* read input lines */
bool get_lines(FILE *fp, std::string &line, template_t &entry)
{
    bool loop = true;
    int c = EOF;

    line.clear();
    entry.maybe_keyword = 0;
    entry.line_count = 1;

    while (loop)
    {
        c = fgetc(fp);

        switch (c)
        {
        case '\n':
            /* concatenate lines ending on '@' */
            if (line.back() == '@') {
                line.back() = '\n';
                entry.line_count++;
                continue;
            }
            loop = false;
            break;

        case EOF:
            if (line.back() == '@') {
                line.pop_back();
            }
            loop = false;
            break;

        case '%':
            entry.maybe_keyword = 1;
            [[fallthrough]];

        default:
            line.push_back(static_cast<char>(c));
            continue;
        }
    }

    entry.data = line.c_str();

    return (c == EOF);
}


/* print note */
int save_note(cio::ofstream &out, bool print_date)
{
    std::stringstream strm;

    strm << "// Do not edit this file!\n"
        "// It was automatically generated by gendlopen";

    if (print_date) {
        struct tm tm = {};
        time_t t = std::time(nullptr);
        bool tm_ok;

#ifdef _WIN32
        tm_ok = (::localtime_s(&tm, &t) == 0);
#else
        tm_ok = (::localtime_r(&t, &tm) != nullptr);
#endif

        if (tm_ok) {
            strm << " on " << std::put_time(&tm, "%F %T %z");
        }
    }

    strm << ".\n"
        "// All changes made will be lost.\n"
        "\n";

    out << strm.str();

    return utils::count_linefeed(strm.str());
}

/* define default library name */
int save_default_libname(
    cio::ofstream &out,
    const std::string &pfx,
    const std::string &lib_a,
    const std::string &lib_w)
{
    std::string str;

    if (lib_a.empty() || lib_w.empty()) {
        return 0;
    }

    str = "/* default library */\n"
        "#ifndef "  + pfx + "_DEFAULT_LIBA\n"
        "# define " + pfx + "_DEFAULT_LIBA " + lib_a + "\n"
        "#endif\n"
        "#ifndef "  + pfx + "_DEFAULT_LIBW\n"
        "# define " + pfx + "_DEFAULT_LIBW " + lib_w + "\n"
        "#endif\n\n";
    out << str;

    return utils::count_linefeed(str);
}

/* extra defines */
int save_extra_defines(cio::ofstream &out, const std::string &defs)
{
    if (defs.empty()) {
        return 0;
    }

    std::string str = "/* extra defines */\n";
    str += defs + '\n';
    out << str;

    return utils::count_linefeed(str);
}

/* typedefs for function pointers */
int save_typedefs(cio::ofstream &out, const vstring_t &tdefs)
{
    if (tdefs.empty()) {
        return 0;
    }

    std::string str = "/* typedefs */\n";

    for (auto &e : tdefs) {
        str += "typedef " + e + ";\n";
    }

    str += '\n';
    out << str;

    return utils::count_linefeed(str);
}

/* extra includes */
int save_includes(cio::ofstream &out, const vstring_t &includes, bool is_cxx)
{
    std::string str = "/* extra headers */\n";

    if (is_cxx) {
        str += "#include <cstddef>\n"  /* size_t, NULL, ... */
               "#include <cstring>\n"; /* strncmp() */
    } else {
        str += "#include <stddef.h>\n"
               "#include <string.h>\n";
    }

    for (auto &e : includes) {
        str += "#include " + e + '\n';
    }

    str += '\n';
    out << str;

    return utils::count_linefeed(str);
}

int save_header_guard_begin(cio::ofstream &out, const std::string &header_guard, bool is_cxx)
{
    std::string str;

    if (header_guard.empty()) {
        str = "\n"
            "#pragma once\n\n";
    } else {
        str = "\n"
            "#ifndef " + header_guard + "\n"
            "#define " + header_guard + "\n\n";
    }

    if (!is_cxx) {
        /* extern C begin */
        str += "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n";
    }

    out << str;

    return utils::count_linefeed(str);
}

/* don't need to count lines anymore */
void save_header_guard_end(cio::ofstream &out, const std::string &header_guard, bool is_cxx)
{
    if (!is_cxx) {
        /* extern C end */
        out << "#ifdef __cplusplus\n"
            "} /* extern \"C\" */\n"
            "#endif\n";
    }

    if (!header_guard.empty()) {
        out << "\n#endif //" << header_guard << "_\n";
    }
}

/* print all found symbols to stdout */
void print_symbols_to_stdout(const vproto_t &objs, const vproto_t &funcs, const vstring_t &tdefs)
{
    cio::ofstream out; /* defaults to STDOUT */
    save_typedefs(out, tdefs);

    std::cout << "/* prototypes */\n";

    auto print_type = [] (const std::string &s)
    {
        if (s.back() == '*') {
            std::cout << s;
        } else {
            std::cout << s << ' ';
        }
    };

    for (const auto &e : objs) {
        print_type(e.type);
        std::cout << e.symbol << ";\n";
    }

    for (const auto &e : funcs) {
        print_type(e.type);
        std::cout << e.symbol << '(' << e.args << ");\n";
    }

    std::cout << "\n/***  " << (objs.size() + funcs.size()) << " matches  ***/" << std::endl;
}

/**
 * Look for a common symbol prefix.
 * Many APIs share a common prefix among their symbols.
 * If you want to load a specific symbol we can use this
 * later for a faster lookup.
 */
size_t common_prefix_length(vstring_t &vec)
{
    /* need at least 2 symbols */
    if (vec.size() < 2) {
        return {};
    }

    /* get shortest symbol length */
    size_t maxlen = vec.at(0).size();

    for (const auto &e : vec) {
        /* prevent `min()' macro expansion from Windows headers */
        maxlen = std::min<size_t>(maxlen, e.size());
    }

    size_t pfxlen = 0;

    for (size_t i = 0; i < maxlen; i++) {
        const char c = vec.at(0).at(i);

        for (const auto &e : vec) {
            if (e.at(i) != c) {
                /* common prefix found (can be empty) */
                return pfxlen;
            }
        }

        pfxlen++;
    }

    /* shortest symbol name is prefix, i.e. if a symbol `foo'
     * and `foobar' exist the prefix is `foo' */
    return pfxlen;
}

/* create a macro that will do a slightly optimized lookup of a
 * given symbol name */
int save_check_symbol_name_macro(cio::ofstream &out, const std::string &pfx_upper,
    const vproto_t &v_prototypes, const vproto_t &v_objects)
{
    vstring_t symbols, temp;
    std::vector<vstring_t> lists;
    std::string str;

    for (const auto &e : v_prototypes) {
        symbols.push_back(e.symbol);
    }

    for (const auto &e : v_objects) {
        symbols.push_back(e.symbol);
    }

    std::sort(symbols.begin(), symbols.end());

    /* #define GDO_CHECK_SYMBOL_NAME() */
    str = "/* symbol name check */\n"
          "#define " + pfx_upper + "_CHECK_SYMBOL_NAME() \\\n";

    /* only 1 symbol */
    if (symbols.size() == 1) {
        str += "  if (symbol != NULL && strcmp(symbol, \"" + symbols.at(0) + "\") == 0) { \\\n"
               "    goto " + pfx_upper + "_JUMP_" + symbols.at(0) + "; \\\n"
               "  }\n\n";

        out << str;

        return utils::count_linefeed(str);
    }

    /* multiple symbols */

    const size_t pfxlen = common_prefix_length(symbols); /* can be 0 */
    const auto pfx = symbols.at(0).substr(0, pfxlen); /* can be empty string */
    const auto str_pfxlen = std::to_string(pfxlen);
    const auto jumplabel = pfx_upper + "_JUMP_" + pfx;

    /* prefix check */
    if (pfxlen == 0) {
        str += "  if (symbol != NULL && *symbol != 0) \\\n";
    } else if (pfxlen == 1) {
        str += "  if (symbol != NULL && *symbol == '" + pfx + "') \\\n";
    } else {
        str += "  if (symbol != NULL && strncmp(symbol, \"" + pfx + "\", " + str_pfxlen + ") == 0) \\\n";
    }

    /* only 2 symbols */
    if (symbols.size() == 2) {
        const auto e0 = symbols.at(0).substr(pfxlen);
        const auto e1 = symbols.at(1).substr(pfxlen);

        str += "  { \\\n"
               "    if (strcmp(symbol + " + str_pfxlen + ", \"" + e0 + "\") == 0) { \\\n"
               "      goto " + jumplabel + e0 + "; \\\n"
               "    } else if (strcmp(symbol + " + str_pfxlen + ", \"" + e1 + "\") == 0) { \\\n"
               "      goto " + jumplabel + e1 + "; \\\n"
               "    } \\\n"
               "  }\n\n";

        out << str;

        return utils::count_linefeed(str);
    }

    /* copy symbol names into alphabetically sorted lists */
    for (const auto &e : symbols) {
        if (!temp.empty() && temp.at(0).front() != e.at(pfxlen)) {
            lists.push_back(temp);
            temp.clear();
        }
        temp.push_back(e.substr(pfxlen));
    }

    if (!temp.empty()) {
        lists.push_back(temp);
    }

    /* switch begin */
    str += "  { \\\n"
           "    switch (*(symbol + " + str_pfxlen + ")) \\\n"
           "    { \\\n";

    /* switch entries */
    for (const auto &v : lists) {
        char c = v.at(0).front();

        if (c == 0) {
            str += "    case 0: /* same as common symbol prefix */ \\\n"
                   "      goto " + jumplabel + "; \\\n";
        } else {
            str += "    case '"; str+=c; str+="': \\\n";

            for (const auto &sym_short : v) {
                auto ptr = sym_short.c_str() + 1;

                /* example: »      GDO_CHECK(helloworld_hello, "ello"); \« */
                str += "      " + pfx_upper + "_CHECK(" + pfx + sym_short + ", \"" + ptr + "\"); \\\n";
            }
        }

        str += "      break; \\\n";
    }

    /* switch end */
    str += "    default: \\\n"
           "      break; \\\n"
           "    } \\\n"
           "  }\n\n";

    /* #define GDO_CHECK() */
    const auto check_macro =
        "#define " + pfx_upper + "_CHECK(LABEL, STR) \\\n"
        "  if (strcmp(symbol + " + std::to_string(pfxlen+1) + ", STR) == 0) { \\\n"
        "    goto " + pfx_upper + "_JUMP_##LABEL; \\\n"
        "  }\n\n";

    /* print */
    out << check_macro << str;

    return utils::count_linefeed(check_macro) + utils::count_linefeed(str);
}

} /* end anonymous namespace */


/* open output file for writing */
void gendlopen::open_ofstream(const fs::path &opath, cio::ofstream &ofs)
{
    if (opath.empty() || opath.filename() == "-") {
        /* default to STDOUT */
        ofs.close();
        return;
    }

    /* delete file to prevent writing data into symlink target */
    if (m_force) {
        fs::remove(opath);
    }

    /* check symlink and not its target */
    if (fs::exists(fs::symlink_status(opath))) {
        throw error("file already exists: " + opath.string());
    }

    /* open file for writing */
    if (!ofs.open(opath)) {
        throw error("failed to open file for writing: " + opath.string());
    }
}

/* read and process custom template */
void gendlopen::read_custom_template()
{
    cio::ofstream ofs;
    std::string buf;
    template_t entry;
    bool param_skip_code = false;
    bool eof = false;
    int templ_lineno = 1; /* input template line count */

    /* open file for reading */
    open_file file(m_custom_template);

    if (!file.is_open()) {
        throw error("failed to open file for reading: " + m_custom_template);
    }

    /* create output file */
    open_ofstream(m_output, ofs);
    FILE *fp = file.file_pointer();

    /* write initial #line directive */
    if (m_line_directive) {
        if (fp == stdin) {
            ofs << "#line 1 \"<STDIN>\"\n";
        } else {
            ofs << "#line 1 \"" << m_custom_template << "\"\n";
        }
    }

    /* parse lines */
    while (!eof) {
        eof = get_lines(fp, buf, entry);
        substitute_line(entry, templ_lineno, param_skip_code, ofs);
        templ_lineno += entry.line_count;
    }
}

/* generate output */
void gendlopen::generate()
{
    cio::ofstream ofs, ofs_body;
    fs::path ofhdr, ofbody;
    std::string header_name, header_guard;
    vtemplate_t header_data, body_data;
    int lines;

    /* tokenize and parse strings from input */
    tokenize();

    /* print symbols and exit */
    if (m_print_symbols) {
        print_symbols_to_stdout(m_objects, m_prototypes, m_typedefs);
        return;
    }

    /* use custom template (`-format' will be ignored) */
    if (!m_custom_template.empty()) {
        read_custom_template();
        return;
    }

    /* output filename */

    const bool use_stdout = (m_output == "-");

    if (!use_stdout) {
        ofbody = ofhdr = CONVERT_FILENAME(m_output);
    }

    bool is_cxx = false;

    switch (m_format)
    {
    case output::c:
        break;
    case output::cxx:
        is_cxx = true;
        break;
    case output::minimal:
        m_separate = false;
        break;
    case output::minimal_cxx:
        is_cxx = true;
        m_separate = false;
        break;
    [[unlikely]] case output::error:
        throw error("output::format == output::error");
    }

    /* disable separate files on stdout */
    if (use_stdout) {
        m_separate = false;
    }

    /* rename file extensions only if we save into separate files */
    if (m_separate) {
        if (is_cxx) {
            ofhdr.replace_extension(".hpp");
            ofbody.replace_extension(".cpp");
        } else {
            ofhdr.replace_extension(".h");
            ofbody.replace_extension(".c");
        }
    }

    /* create header filename */
    if (use_stdout) {
        header_name = m_pfx;
        header_name += is_cxx ? ".hpp" : ".h";
    } else {
        header_name = ofhdr.filename().string();
    }

    /* save pointers to template lines in header_data and body_data */
    create_template_data_lists(header_data, body_data);


    /* define namespace macro */
    if (is_cxx) {
        m_defines += "#define " + m_pfx_upper + "_CXX_NAMESPACE"
            "  namespace " + m_pfx_lower + '\n';
    }


    /*************** header data ***************/
    auto print_lineno = [&, this] ()
    {
        if (m_line_directive) {
            ofs << "#line " << (lines + 2) << " \"" << header_name << "\"\n";
            lines++;
        }
    };

    if (!m_pragma_once) {
        header_guard = '_' + m_pfx_upper + '_' + utils::convert_to_upper(header_name) + '_';
    }

    open_ofstream(ofhdr, ofs);             /* open stream */

    lines  = save_note(ofs, m_print_date); /* top note */
    lines += save_license_data(ofs);       /* license */
    lines += save_header_guard_begin(ofs,  /* header guard begin */
        header_guard, is_cxx);

    /* filename macros */
    lines += save_filename_macros_data(ofs);

    /* print extra data after filename macros as includes or defines
     * might make use of it */
    print_lineno();
    lines += save_extra_defines(ofs, m_defines);     /* #defines */
    lines += save_default_libname(ofs, m_pfx_upper,  /* default library name */
        m_deflib_a, m_deflib_w);
    lines += save_includes(ofs, m_includes, is_cxx); /* #includes */
    lines += save_typedefs(ofs, m_typedefs);         /* typedefs */
    lines += save_check_symbol_name_macro(ofs,       /* GDO_CHECK_SYMBOL_NAME() */
        m_pfx_upper, m_prototypes, m_objects);

    /* header template */
    lines += substitute(header_data, ofs);

    /* header guard end */
    print_lineno();
    save_header_guard_end(ofs, header_guard, is_cxx);

    /* close stream */
    ofs.close();

    /**************** body data ****************/
    if (m_separate) {
        open_ofstream(ofbody, ofs_body);    /* open stream */
        save_note(ofs_body, m_print_date);  /* note */
        save_license_data(ofs_body);        /* license */
        ofs_body << "#include \""           /* include header file */
            << header_name << "\"\n\n";
        substitute(body_data, ofs_body);    /* body template */
    }
}

