/**
 Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 SPDX-License-Identifier: MIT
 Copyright (c) 2023-2025 Carsten Janssen

 Permission is hereby  granted, free of charge, to any  person obtaining a copy
 of this software and associated  documentation files (the "Software"), to deal
 in the Software  without restriction, including without  limitation the rights
 to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
 copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
 IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
 FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
 AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
 LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
**/

/**
 * Generate the output data (STDOUT or save to file).
 */

#include <stdio.h>
#include <algorithm>
#include <ctime>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "cio_ofstream.hpp"
#include "gendlopen.hpp"
#include "filesystem_compat.hpp"
#include "open_file.hpp"
#include "types.hpp"
#include "utils.hpp"



namespace save
{

cio::ofstream ofs;


/* print note */
int note(bool print_date)
{
    std::stringstream strm;

    strm << "// Do not edit this file!\n"
        "// It was automatically generated by gendlopen";

    if (print_date) {
        struct tm tm = {};
        time_t t = std::time(nullptr);
        bool tm_ok;

#ifdef _WIN32
        tm_ok = (::localtime_s(&tm, &t) == 0);
#else
        tm_ok = (::localtime_r(&t, &tm) != nullptr);
#endif

        if (tm_ok) {
            strm << " on " << std::put_time(&tm, "%F %T %z");
        }
    }

    strm << ".\n"
        "// All changes made will be lost.\n"
        "\n";

    ofs << strm.str();

    return utils::count_linefeed(strm.str());
}


/* extra defines */
int extra_defines(const std::string &defs)
{
    if (defs.empty()) {
        return 0;
    }

    std::string str = "/* extra defines */\n";
    str += defs + '\n';
    ofs << str;

    return utils::count_linefeed(str);
}

/* typedefs for function pointers */
int typedefs(const vstring_t &tdefs)
{
    if (tdefs.empty()) {
        return 0;
    }

    std::string str = "/* typedefs */\n";

    for (const auto &e : tdefs) {
        str += "typedef " + e + ";\n";
    }

    str += '\n';
    ofs << str;

    return utils::count_linefeed(str);
}

/* extra includes */
int includes(const vstring_t &incs, bool is_cxx)
{
    std::string str = "/* extra headers */\n";

    if (is_cxx) {
        str += "#include <cstddef>\n"  /* size_t, NULL, ... */
               "#include <cstring>\n"; /* strncmp() */
    } else {
        str += "#include <stddef.h>\n"
               "#include <string.h>\n";
    }

    for (auto &e : incs) {
        str += "#include " + e + '\n';
    }

    str += '\n';
    ofs << str;

    return utils::count_linefeed(str);
}

int header_guard_begin(const std::string &header_guard, bool is_cxx)
{
    std::string str;

    if (header_guard.empty()) {
        str = "\n"
            "#pragma once\n\n";
    } else {
        str = "\n"
            "#ifndef " + header_guard + "\n"
            "#define " + header_guard + "\n\n";
    }

    if (!is_cxx) {
        /* extern C begin */
        str += "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n";
    }

    ofs << str;

    return utils::count_linefeed(str);
}

/* don't need to count lines anymore */
void header_guard_end(const std::string &header_guard, bool is_cxx)
{
    if (!is_cxx) {
        /* extern C end */
        ofs << "#ifdef __cplusplus\n"
            "} /* extern \"C\" */\n"
            "#endif\n";
    }

    if (!header_guard.empty()) {
        ofs << "\n#endif //" << header_guard << "_\n";
    }
}

} /* end namespace save */


/* open output file for writing */
void gendlopen::open_ofstream(const fs_path_t &opath)
{
    std::string opath_str;

#ifdef __cpp_lib_filesystem
    opath_str = opath.string();
#else
    opath_str = opath;
#endif

    if (opath.empty() || opath_str == "-") {
        /* default to STDOUT */
        save::ofs.close();
        return;
    }

    /* delete file to prevent writing data into symlink target */
    if (m_force) {
        fs::remove_file(opath);
    }

    /* check symlink and not its target */
    if (fs::exists_lstat(opath)) {
        throw error("file already exists: " + opath_str);
    }

    /* open file for writing */
    if (!save::ofs.open(opath)) {
        throw error("failed to open file for writing: " + opath_str);
    }
}


/* generate output */
void gendlopen::generate()
{
    fs_path_t ofhdr, ofbody;
    std::string header_name, header_guard;
    vtemplate_t header_data, body_data;
    int lines = 0;
    bool is_cxx = false;
    bool is_minimal = false;

    /************* lambda functions *************/

    auto print_lineno = [&, this] () {
        if (m_line_directive) {
            lines++;
            save::ofs << "#line " << (lines + 1) << " \"" << header_name << "\"\n";
        }
    };

    auto HEADER_NOTE_AND_LICENSE = [&, this] () {
        lines += save::note(m_print_date);
        lines += data::license(m_line_directive);
    };

    auto HEADER_GUARD_BEGIN = [&, this] () {
        if (!m_pragma_once) {
            header_guard = '_' + m_pfx_upper + '_' + utils::convert_to_upper(header_name) + '_';
        }
        lines += save::header_guard_begin(header_guard, is_cxx);
    };

    auto HEADER_FILENAME_MACROS = [&] () {
        lines += data::filename_macros(m_line_directive);
    };

    auto HEADER_GENERATED_DATA = [&, this] () {
        /* print extra data after filename macros as includes or defines
         * might make use of it */
        if (m_line_directive) {
            print_lineno();
            save::ofs << '\n'; /* extra padding */
            lines++;
        }

        lines += save::extra_defines(m_defines);
        lines += save::includes(m_includes, is_cxx);
        lines += save::typedefs(m_typedefs);

        /* minimal/plugin headers don't need this */
        if (!is_minimal && m_format != output::plugin) {
            lines += save::symbol_name_lookup(m_pfx_upper, m_prototypes, m_objects);
        }
    };

    auto HEADER_TEMPLATE_DATA = [&] () {
        lines += substitute(header_data);
    };

    auto HEADER_GUARD_END = [&] () {
        print_lineno();
        save::header_guard_end(header_guard, is_cxx);
    };

    auto BODY_NOTE_AND_LICENSE = [&, this] () {
        save::note(m_print_date);
        data::license(m_line_directive);
    };

    auto BODY_INCLUDE_HEADER = [&, this] () {
        save::ofs << '\n';
        save::ofs << "#define " << m_pfx_upper << "_INCLUDED_IN_BODY\n";
        save::ofs << "#include \"" << header_name << "\"\n\n";
    };

    auto BODY_TEMPLATE_DATA = [&] () {
        substitute(body_data);
    };

    /********************************************/

    /* output filename */

    const bool use_stdout = (m_output == "-");

    if (!use_stdout)
    {
#ifdef MINGW32_NEED_CONVERT_FILENAME
        ofbody = ofhdr = fs::convert_filename(m_output);
#else
        ofbody = ofhdr = m_output;
#endif
    }

    switch (m_format)
    {
    case output::c:
    case output::plugin:
        break;

    case output::cxx:
        is_cxx = true;
        break;

    case output::minimal:
        m_separate = false;
        is_minimal = true;
        break;

    case output::minimal_cxx:
        is_cxx = true;
        m_separate = false;
        is_minimal = true;
        break;

    [[unlikely]] case output::error:
        throw error(std::string(__func__) + ": m_format == output::error");
    }

    /* disable separate files on stdout */
    if (use_stdout) {
        m_separate = false;
    }

    /* rename file extensions only if we save into separate files */
    if (m_separate) {
        if (is_cxx) {
            fs::replace_extension(ofhdr, ".hpp");
            fs::replace_extension(ofbody, ".cpp");
        } else {
            fs::replace_extension(ofhdr, ".h");
            fs::replace_extension(ofbody, ".c");
        }
    }

    /* create header filename */
    if (use_stdout) {
        header_name = m_pfx;
        header_name += is_cxx ? ".hpp" : ".h";
    } else {
        header_name = fs::filename(ofhdr);
    }

    /* define GDO_SEPARATE if saving into separate files */
    if (m_separate) {
        m_defines += "#define " + m_pfx_upper + "_SEPARATE\n";
    }

    /* default library name */
    if (!m_deflib_a.empty() && !m_deflib_w.empty()) {
        m_defines += "#define " + m_pfx_upper + "_HARDCODED_DEFAULT_LIBA " + m_deflib_a + '\n';
        m_defines += "#define " + m_pfx_upper + "_HARDCODED_DEFAULT_LIBW " + m_deflib_w + '\n';
    }

    /* save pointers to template lines in header_data and body_data */
    data::create_template_lists(header_data, body_data, m_format, m_separate);


    /*************** header data ***************/
    open_ofstream(ofhdr);

    HEADER_NOTE_AND_LICENSE();
    HEADER_GUARD_BEGIN();

    HEADER_FILENAME_MACROS();
    HEADER_GENERATED_DATA();

    HEADER_TEMPLATE_DATA();

    HEADER_GUARD_END();

    save::ofs.close();


    /**************** body data ****************/
    if (!body_data.empty()) {
        open_ofstream(ofbody);

        BODY_NOTE_AND_LICENSE();
        BODY_INCLUDE_HEADER();

        BODY_TEMPLATE_DATA();

        save::ofs.close();
    }
}

