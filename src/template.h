/* this file was automatically generated; do not edit! */

#pragma once

/* filename_macros.h */
static constexpr template_t filename_macros[] = {
  { "#line 1 \"<built-in>/filename_macros.h\"", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                              filename macros                              */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "/* default library filename extension */", 0, 1 },
  { "#ifdef LIBEXT", 0, 1 },
  { "# undef LIBEXT", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef LIBEXTA", 0, 1 },
  { "# undef LIBEXTA", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef LIBEXTW", 0, 1 },
  { "# undef LIBEXTW", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "# define LIBEXTA    \".dll\"", 0, 1 },
  { "# define LIBEXTW   L\".dll\"", 0, 1 },
  { "#elif defined(__APPLE__)", 0, 1 },
  { "# define LIBEXTA    \".dylib\"", 0, 1 },
  { "# define LIBEXTW   L\".dylib\"", 0, 1 },
  { "#elif defined(_AIX)", 0, 1 },
  { "# define LIBEXTA    \".a\"", 0, 1 },
  { "# define LIBEXTW   L\".a\"", 0, 1 },
  { "#else /* ELF */", 0, 1 },
  { "# define LIBEXTA    \".so\"", 0, 1 },
  { "# define LIBEXTW   L\".so\"", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/**", 0, 1 },
  { " * library name with API number", 0, 1 },
  { " *", 0, 1 },
  { " * Examples using LIBNAME(foo, 1.2) macro:", 0, 1 },
  { " *", 0, 1 },
  { " * Windows: libfoo-1.2.dll", 0, 1 },
  { " * De-facto standard when libraries are ported to Windows.", 0, 1 },
  { " *", 0, 1 },
  { " * macOS: libfoo.1.2.dylib", 0, 1 },
  { " *", 0, 1 },
  { " * AIX: libfoo.a", 0, 1 },
  { " * AIX uses archive files without API number.", 0, 1 },
  { " *", 0, 1 },
  { " * Android: libfoo.so", 0, 1 },
  { " * ELF format but without API number.", 0, 1 },
  { " *", 0, 1 },
  { " * ELF: libfoo.so.1.2", 0, 1 },
  { " */", 0, 1 },
  { "#ifdef LIBNAME", 0, 1 },
  { "# undef LIBNAME", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef LIBNAMEA", 0, 1 },
  { "# undef LIBNAMEA", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef LIBNAMEW", 0, 1 },
  { "# undef LIBNAMEW", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \"-\" #API \".dll\"", 0, 1 },
  { "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \"-\" #API \".dll\"", 0, 1 },
  { "#elif defined(__APPLE__)", 0, 1 },
  { "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".\" #API \".dylib\"", 0, 1 },
  { "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".\" #API \".dylib\"", 0, 1 },
  { "#elif defined(_AIX)", 0, 1 },
  { "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".a\"", 0, 1 },
  { "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".a\"", 0, 1 },
  { "#elif defined(__ANDROID__)", 0, 1 },
  { "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".so\"", 0, 1 },
  { "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".so\"", 0, 1 },
  { "#else /* default ELF filename */", 0, 1 },
  { "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".so.\" #API", 0, 1 },
  { "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".so.\" #API", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* wide/narrow char default macros */", 0, 1 },
  { "#if defined(_WIN32) && defined(_UNICODE)", 0, 1 },
  { "# define LIBEXT              LIBEXTW", 0, 1 },
  { "# define LIBNAME(NAME, API)  LIBNAMEW(NAME, API)", 0, 1 },
  { "#else", 0, 1 },
  { "# define LIBEXT              LIBEXTA", 0, 1 },
  { "# define LIBNAME(NAME, API)  LIBNAMEA(NAME, API)", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { NULL, 0, 0 }
};

/* license.h */
static constexpr template_t license[] = {
  { "/**", 0, 1 },
  { " Licensed under the MIT License <http://opensource.org/licenses/MIT>.", 0, 1 },
  { " SPDX-License-Identifier: MIT", 0, 1 },
  { " Copyright (c) 2023-2025 Carsten Janssen", 0, 1 },
  { "", 0, 1 },
  { " Permission is hereby  granted, free of charge, to any  person obtaining a copy", 0, 1 },
  { " of this software and associated  documentation files (the \"Software\"), to deal", 0, 1 },
  { " in the Software  without restriction, including without  limitation the rights", 0, 1 },
  { " to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell", 0, 1 },
  { " copies  of  the Software,  and  to  permit persons  to  whom  the Software  is", 0, 1 },
  { " furnished to do so, subject to the following conditions:", 0, 1 },
  { "", 0, 1 },
  { " The above copyright notice and this permission notice shall be included in all", 0, 1 },
  { " copies or substantial portions of the Software.", 0, 1 },
  { "", 0, 1 },
  { " THE SOFTWARE  IS PROVIDED \"AS  IS\", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR", 0, 1 },
  { " IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,", 0, 1 },
  { " FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE", 0, 1 },
  { " AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER", 0, 1 },
  { " LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,", 0, 1 },
  { " OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE", 0, 1 },
  { " SOFTWARE.", 0, 1 },
  { "**/", 0, 1 },
  { NULL, 0, 0 }
};

/* common.h */
static constexpr template_t common_header[] = {
  { "#line 1 \"<built-in>/common.h\"", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                         common macros and headers                         */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "/* whether to use WinAPI or dlfcn */", 0, 1 },
  { "#if defined(_WIN32) && !defined(GDO_USE_DLOPEN)", 0, 1 },
  { "# define GDO_WINAPI", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "# include <windows.h>", 0, 1 },
  { "#else", 0, 1 },
  { "/* <features.h> is a Glibc header that defines __GLIBC__", 0, 1 },
  { " * and will be automatically included with <stdio.h> if present */", 0, 1 },
  { "# include <stdio.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef GDO_WINAPI", 0, 1 },
  { "# include <dlfcn.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* default library name */", 0, 1 },
  { "#if !defined(GDO_DEFAULT_LIBA) && defined(GDO_HARDCODED_DEFAULT_LIBA)", 0, 1 },
  { "# define GDO_DEFAULT_LIBA  GDO_HARDCODED_DEFAULT_LIBA", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_DEFAULT_LIBW) && defined(GDO_HARDCODED_DEFAULT_LIBW)", 0, 1 },
  { "# define GDO_DEFAULT_LIBW  GDO_HARDCODED_DEFAULT_LIBW", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef GDO_DEFAULT_LIB", 0, 1 },
  { "# if defined(GDO_DEFAULT_LIBW) && defined(GDO_WINAPI) && defined(_UNICODE)", 0, 1 },
  { "#  define GDO_DEFAULT_LIB  GDO_DEFAULT_LIBW", 0, 1 },
  { "# elif defined(GDO_DEFAULT_LIBA)", 0, 1 },
  { "#  define GDO_DEFAULT_LIB  GDO_DEFAULT_LIBA", 0, 1 },
  { "# endif", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* whether to use dlinfo(3);", 0, 1 },
  { " * n/a on Windows, macOS, OpenBSD and Haiku */", 0, 1 },
  { "#if defined(_WIN32) || \\", 0, 1 },
  { "    defined(__APPLE__) || \\", 0, 1 },
  { "    defined(__OpenBSD__) || \\", 0, 1 },
  { "    defined(__HAIKU__)", 0, 1 },
  { "# define _GDO_TARGET_NO_DLINFO", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_DISABLE_DLINFO", 0, 1 },
  { "# ifdef GDO_HAVE_DLINFO", 0, 1 },
  { "# undef GDO_HAVE_DLINFO", 0, 1 },
  { "# endif", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_DISABLE_DLINFO) && \\", 0, 1 },
  { "    !defined(_GDO_TARGET_NO_DLINFO) && \\", 0, 1 },
  { "    !defined(GDO_HAVE_DLINFO)", 0, 1 },
  { "# define GDO_HAVE_DLINFO", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAVE_DLINFO", 0, 1 },
  { "# include <link.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* whether to use dlmopen(3);", 0, 1 },
  { " * only available on Glibc and Solaris/IllumOS */", 0, 1 },
  { "#ifdef GDO_DISABLE_DLMOPEN", 0, 1 },
  { "# ifdef GDO_HAVE_DLMOPEN", 0, 1 },
  { "# undef GDO_HAVE_DLMOPEN", 0, 1 },
  { "# endif", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_DISABLE_DLMOPEN) && \\", 0, 1 },
  { "    (defined(__GLIBC__) || defined(__sun)) && \\", 0, 1 },
  { "    !defined(GDO_HAVE_DLMOPEN)", 0, 1 },
  { "# define GDO_HAVE_DLMOPEN", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* dlopen(3) flags for compatibility with LoadLibrary() */", 0, 1 },
  { "/* taken from different implementations of dlfcn.h */", 0, 1 },
  { "#ifndef RTLD_LAZY", 0, 1 },
  { "#define RTLD_LAZY 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_NOW", 0, 1 },
  { "#define RTLD_NOW 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_GLOBAL", 0, 1 },
  { "#define RTLD_GLOBAL 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_LOCAL", 0, 1 },
  { "#define RTLD_LOCAL 0", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef RTLD_BINDING_MASK", 0, 1 },
  { "#define RTLD_BINDING_MASK 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_CONFGEN", 0, 1 },
  { "#define RTLD_CONFGEN 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_DEEPBIND", 0, 1 },
  { "#define RTLD_DEEPBIND 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_FIRST", 0, 1 },
  { "#define RTLD_FIRST 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_GROUP", 0, 1 },
  { "#define RTLD_GROUP 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_MEMBER", 0, 1 },
  { "#define RTLD_MEMBER 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_MODEMASK", 0, 1 },
  { "#define RTLD_MODEMASK 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_NOAUTODEFER", 0, 1 },
  { "#define RTLD_NOAUTODEFER 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_NODELETE", 0, 1 },
  { "#define RTLD_NODELETE 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_NOLOAD", 0, 1 },
  { "#define RTLD_NOLOAD 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_PARENT", 0, 1 },
  { "#define RTLD_PARENT 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_TRACE", 0, 1 },
  { "#define RTLD_TRACE 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef RTLD_WORLD", 0, 1 },
  { "#define RTLD_WORLD 0", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef DL_LAZY", 0, 1 },
  { "#define DL_LAZY RTLD_LAZY  /* compat */", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* LoadLibrary() flags for compatibility with dlopen() */", 0, 1 },
  { "/* https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw */", 0, 1 },
  { "#ifndef DONT_RESOLVE_DLL_REFERENCES", 0, 1 },
  { "#define DONT_RESOLVE_DLL_REFERENCES 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_IGNORE_CODE_AUTHZ_LEVEL", 0, 1 },
  { "#define LOAD_IGNORE_CODE_AUTHZ_LEVEL 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_AS_DATAFILE", 0, 1 },
  { "#define LOAD_LIBRARY_AS_DATAFILE 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE", 0, 1 },
  { "#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_AS_IMAGE_RESOURCE", 0, 1 },
  { "#define LOAD_LIBRARY_AS_IMAGE_RESOURCE 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SEARCH_APPLICATION_DIR", 0, 1 },
  { "#define LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SEARCH_DEFAULT_DIRS", 0, 1 },
  { "#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR", 0, 1 },
  { "#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SEARCH_SYSTEM32", 0, 1 },
  { "#define LOAD_LIBRARY_SEARCH_SYSTEM32 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SEARCH_USER_DIRS", 0, 1 },
  { "#define LOAD_LIBRARY_SEARCH_USER_DIRS 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_WITH_ALTERED_SEARCH_PATH", 0, 1 },
  { "#define LOAD_WITH_ALTERED_SEARCH_PATH 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_REQUIRE_SIGNED_TARGET", 0, 1 },
  { "#define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET 0", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef LOAD_LIBRARY_SAFE_CURRENT_DIRS", 0, 1 },
  { "#define LOAD_LIBRARY_SAFE_CURRENT_DIRS 0", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* symbol visibility, i.e. __declspec(dllexport)", 0, 1 },
  { " * or __attribute__((visibility(\"default\"))) */", 0, 1 },
  { "#ifndef GDO_VISIBILITY", 0, 1 },
  { "# define GDO_VISIBILITY", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* default flags */", 0, 1 },
  { "#ifndef GDO_DEFAULT_FLAGS", 0, 1 },
  { "# ifdef GDO_WINAPI", 0, 1 },
  { "#  define GDO_DEFAULT_FLAGS 0", 0, 1 },
  { "# else", 0, 1 },
  { "#  define GDO_DEFAULT_FLAGS (RTLD_LAZY | RTLD_MEMBER)", 0, 1 },
  { "# endif", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "%PARAM_SKIP_REMOVE_BEGIN%", 1, 1 },
  { "/* wrapped functions are enabled */", 0, 1 },
  { "#if defined(GDO_ENABLE_AUTOLOAD) && !defined(GDO_DEFAULT_LIB)", 0, 1 },
  { "# error You need to define GDO_DEFAULT_LIB if you want to make use of GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "#endif", 0, 1 },
  { "#if defined(GDO_DELAYLOAD) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "# error You need to define GDO_ENABLE_AUTOLOAD if you want to make use of GDO_DELAYLOAD", 0, 1 },
  { "#endif", 0, 1 },
  { "%PARAM_SKIP_USE_BEGIN%", 1, 1 },
  { "/* wrapped functions are disabled */", 0, 1 },
  { "#if defined(GDO_WRAP_FUNCTIONS)", 0, 1 },
  { "# error \"GDO_WRAP_FUNCTIONS\" defined but wrapped functions were disabled with \"-param=skip\"", 0, 1 },
  { "#endif", 0, 1 },
  { "#if defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "# error \"GDO_ENABLE_AUTOLOAD\" defined but wrapped functions were disabled with \"-param=skip\"", 0, 1 },
  { "#endif", 0, 1 },
  { "%PARAM_SKIP_END%", 1, 1 },
  { "", 0, 1 },
  { NULL, 0, 0 }
};

/* c.h */
static constexpr template_t c_header[] = {
  { "#line 1 \"<built-in>/c.h\"", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "# include <tchar.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifndef __cplusplus", 0, 1 },
  { "# include <stdbool.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/***", 0, 1 },
  { "", 0, 1 },
  { "******************", 0, 1 },
  { "*   gdo_char_t   *", 0, 1 },
  { "******************", 0, 1 },
  { "", 0, 1 },
  { "If compiling for win32 and `_UNICODE` is defined and `GDO_USE_DLOPEN` is NOT defined", 0, 1 },
  { "`gdo_char_t` will become `wchar_t`.", 0, 1 },
  { "", 0, 1 },
  { "Otherwise `gdo_char_t` will become `char`.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "**************************", 0, 1 },
  { "*   Functions provided   *", 0, 1 },
  { "**************************", 0, 1 },
  { "", 0, 1 },
  { "bool               gdo_load_lib ();", 0, 1 },
  { "bool               gdo_load_lib_and_symbols ();", 0, 1 },
  { "bool               gdo_load_lib_name (const gdo_char_t *filename);", 0, 1 },
  { "bool               gdo_load_lib_name_and_symbols (const gdo_char_t *filename);", 0, 1 },
  { "bool               gdo_load_lib_args (const gdo_char_t *filename, int flags, bool new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "bool               gdo_lib_is_loaded ();", 0, 1 },
  { "bool               gdo_free_lib ();", 0, 1 },
  { "", 0, 1 },
  { "bool               gdo_all_symbols_loaded ();", 0, 1 },
  { "bool               gdo_no_symbols_loaded ();", 0, 1 },
  { "bool               gdo_any_symbol_loaded ();", 0, 1 },
  { "bool               gdo_load_all_symbols ();", 0, 1 },
  { "bool               gdo_load_symbol (int symbol_num);", 0, 1 },
  { "bool               gdo_load_symbol_name (const char *symbol);", 0, 1 },
  { "", 0, 1 },
  { "bool               gdo_all_symbols_loaded ();", 0, 1 },
  { "bool               gdo_no_symbols_loaded ();", 0, 1 },
  { "bool               gdo_any_symbol_loaded ();", 0, 1 },
  { "", 0, 1 },
  { "const gdo_char_t * gdo_last_error ();", 0, 1 },
  { "gdo_char_t *       gdo_lib_origin ();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_lib ();", 0, 1 },
  { "", 0, 1 },
  { "    Load the library specified by the macro GDO_DEFAULT_LIB using default flags.", 0, 1 },
  { "    This function is not available if GDO_DEFAULT_LIB was not defined.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_lib_and_symbols ();", 0, 1 },
  { "", 0, 1 },
  { "    Calls gdo_load_lib() and gdo_load_symbols().", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_lib_name (const gdo_char_t *filename);", 0, 1 },
  { "", 0, 1 },
  { "    Load the library specified by `filename' using default flags.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_lib_name_and_symbols (const gdo_char_t *filename);", 0, 1 },
  { "", 0, 1 },
  { "    Calls gdo_load_lib_name() and gdo_load_symbols().", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_lib_args (const gdo_char_t *filename, int flags, bool new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "    Load the library; `filename' and `flags' are passed to the underlying library", 0, 1 },
  { "    loading functions.", 0, 1 },
  { "", 0, 1 },
  { "    If `new_namespace' is true the library will be loaded into a new namespace.", 0, 1 },
  { "    This is done using dlmopen() with the LM_ID_NEWLM argument.", 0, 1 },
  { "    This argument is only used on Glibc and if _GNU_SOURCE was defined.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_lib_is_loaded ();", 0, 1 },
  { "", 0, 1 },
  { "    Returns true if the library was successfully loaded.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_free_lib ();", 0, 1 },
  { "", 0, 1 },
  { "    Free/release library handle.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_all_symbols ();", 0, 1 },
  { "", 0, 1 },
  { "    Load the symbols. This function can safely be called multiple times.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_load_symbol (int symbol_num);", 0, 1 },
  { "", 0, 1 },
  { "    Load a specific symbol.", 0, 1 },
  { "    `symbol_num' is an enumeration value: `GDO_LOAD_<symbol_name>'", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_all_symbols_loaded ();", 0, 1 },
  { "", 0, 1 },
  { "    Returns true if ALL symbols were successfully loaded.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_no_symbols_loaded ();", 0, 1 },
  { "", 0, 1 },
  { "    Returns true if NO symbols were loaded at all.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "bool gdo_any_symbol_loaded ();", 0, 1 },
  { "", 0, 1 },
  { "    Returns true if 1 or more symbols were successfully loaded.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "const gdo_char_t *gdo_last_error ();", 0, 1 },
  { "", 0, 1 },
  { "    Returns a pointer to the error message buffer with the last saved error string.", 0, 1 },
  { "    This buffer can be empty and is in fact cleared when no error occured in a function.", 0, 1 },
  { "    This function doesn't return a null pointer.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "gdo_char_t *gdo_lib_origin ();", 0, 1 },
  { "", 0, 1 },
  { "    Return the full library path. The returned string must be deallocated with free().", 0, 1 },
  { "    On error or if no library was loaded NULL is returned.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "****************************************************", 0, 1 },
  { "* The following options may be set through macros: *", 0, 1 },
  { "****************************************************", 0, 1 },
  { "", 0, 1 },
  { "GDO_USE_DLOPEN", 0, 1 },
  { "    If defined use `dlopen()' API on win32 targets.", 0, 1 },
  { "    On other targets `dlopen()' is always used.", 0, 1 },
  { "", 0, 1 },
  { "GDO_STATIC", 0, 1 },
  { "    If defined `static inline' linkage is used for all functions.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_FLAGS", 0, 1 },
  { "    Override the default flags to use when loading a library.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_LIB", 0, 1 },
  { "    Set a default library name through this macro (including double quote", 0, 1 },
  { "    marks). This macro must be defined if you want to set GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "    or if you want to use the `gdo_load_lib()' function.", 0, 1 },
  { "", 0, 1 },
  { "GDO_WRAP_FUNCTIONS", 0, 1 },
  { "    Use actual wrapped functions instead of a name alias. This is useful if you", 0, 1 },
  { "    want to create a library to later link an application against.", 0, 1 },
  { "", 0, 1 },
  { "GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "    Define this macro if you want to use auto-loading wrapper functions.", 0, 1 },
  { "    This means you don't need to explicitly call library load functions.", 0, 1 },
  { "    The first wrapper function called will load all symbols at once.", 0, 1 },
  { "    It requires GDO_DEFAULT_LIB to be defined.", 0, 1 },
  { "    If an error occures during loading these functions print an error message", 0, 1 },
  { "    and call `exit(1)'!", 0, 1 },
  { "", 0, 1 },
  { "GDO_DELAYLOAD", 0, 1 },
  { "    Same as GDO_ENABLE_AUTOLOAD but only the requested symbol is loaded when its", 0, 1 },
  { "    wrapper function is called instead of all symbols.", 0, 1 },
  { "    It requires GDO_ENABLE_AUTOLOAD to be defined.", 0, 1 },
  { "", 0, 1 },
  { "GDO_AUTO_RELEASE", 0, 1 },
  { "    If defined the library handle will automatically be released on program exit.", 0, 1 },
  { "", 0, 1 },
  { "GDO_VISIBILITY", 0, 1 },
  { "    You can set the symbol visibility of wrapped functions (enabled with GDO_WRAP_FUNCTIONS)", 0, 1 },
  { "    using this macro.", 0, 1 },
  { "", 0, 1 },
  { "GDO_USE_MESSAGE_BOX", 0, 1 },
  { "    If win32 API is used and GDO_ENABLE_AUTOLOAD was activated this will enable", 0, 1 },
  { "    error messages from auto-loading to be displayed in MessageBox windows.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_ALIASING", 0, 1 },
  { "    Don't use preprocessor macros to alias symbol names. Use with care.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_DLINFO", 0, 1 },
  { "    Always disable usage of `dlinfo(3)'.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_DLMOPEN", 0, 1 },
  { "    Always disable usage of `dlmopen(3)'.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "*****************", 0, 1 },
  { "* Helper macros *", 0, 1 },
  { "*****************", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_FLAGS", 0, 1 },
  { "    Default flags for `dlopen()' or `LoadLibraryEx()'", 0, 1 },
  { "", 0, 1 },
  { "GDO_ALIAS_<symbol>", 0, 1 },
  { "    Convenience macro to access the symbol pointer. I.e. `GDO_ALIAS_helloworld' will", 0, 1 },
  { "    access the pointer to `helloworld'.", 0, 1 },
  { "", 0, 1 },
  { "LIBNAME(NAME, API)", 0, 1 },
  { "LIBNAMEA(NAME, API)", 0, 1 },
  { "LIBNAMEW(NAME, API)", 0, 1 },
  { "    Convenience macro to create versioned library names for DLLs, dylibs and DSOs,", 0, 1 },
  { "    including double quote marks.", 0, 1 },
  { "    LIBNAME(z,1) for example will become \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\".", 0, 1 },
  { "", 0, 1 },
  { "LIBEXT", 0, 1 },
  { "LIBEXTA", 0, 1 },
  { "LIBEXTW", 0, 1 },
  { "    Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").", 0, 1 },
  { "    Useful i.e. on plugins.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "*********", 0, 1 },
  { "* Hooks *", 0, 1 },
  { "*********", 0, 1 },
  { "", 0, 1 },
  { "GDO_HOOK_<function>(...)", 0, 1 },
  { "    Define a hook macro that will be inserted into a wrap function.", 0, 1 },
  { "    The hook is placed before the actual function call.", 0, 1 },
  { "    If you want to call the function inside the macro you must do so using the GDO_ALIAS_* prefix.", 0, 1 },
  { "    Parameter names are taken from the function prototype declarations (or it's \"a, b, c\" and so on", 0, 1 },
  { "    if the header was created with `-param=create'). A hook may be left undefined.", 0, 1 },
  { "    For example if a function declaration is `int sum_of_a_and_b(int val_a, int val_b)':", 0, 1 },
  { "    #define GDO_HOOK_sum_of_a_and_b(...) \\", 0, 1 },
  { "      printf(\"debug: the sum of %d and %d is %d\\n\", val_a, val_b, GDO_ALIAS_sum_of_a_and_b(__VA_ARGS__));", 1, 1 },
  { "", 0, 1 },
  { "***/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                                   C API                                   */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* linkage */", 0, 1 },
  { "#ifdef GDO_STATIC", 0, 1 },
  { "# define GDO_LINKAGE      static inline", 0, 1 },
  { "# define GDO_OBJ_LINKAGE  static", 0, 1 },
  { "# define GDO_DECL         static inline", 0, 1 },
  { "# define GDO_OBJ_DECL     static", 0, 1 },
  { "#else", 0, 1 },
  { "# define GDO_LINKAGE      /**/", 0, 1 },
  { "# define GDO_OBJ_LINKAGE  /**/", 0, 1 },
  { "# define GDO_DECL         extern", 0, 1 },
  { "# define GDO_OBJ_DECL     extern", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* char / wchar_t */", 0, 1 },
  { "#if defined(GDO_WINAPI) && defined(_UNICODE)", 0, 1 },
  { "typedef wchar_t gdo_char_t;", 0, 1 },
  { "#else", 0, 1 },
  { "typedef char    gdo_char_t;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Our library and symbols handle */", 0, 1 },
  { "typedef struct gdo_handle", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    HMODULE handle;", 0, 1 },
  { "    DWORD last_errno;", 0, 1 },
  { "    /* FormatMessage: according to MSDN the maximum is either 64k or 128k */", 0, 1 },
  { "    gdo_char_t buf_formatted[64*1024];", 0, 1 },
  { "#else", 0, 1 },
  { "    void *handle;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    bool call_free_lib_is_registered;", 0, 1 },
  { "    gdo_char_t buf[8*1024];", 0, 1 },
  { "", 0, 1 },
  { "    /* symbols */", 0, 1 },
  { "    struct _gdo_ptr {", 0, 1 },
  { "        %%type%% (*%%func_symbol%%)(%%args%%);", 1, 1 },
  { "        %%obj_type%% *%%obj_symbol%%;", 1, 1 },
  { "    } ptr;", 0, 1 },
  { "", 0, 1 },
  { "} gdo_handle_t;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "GDO_OBJ_DECL gdo_handle_t gdo_hndl;", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_DEFAULT_LIB", 0, 1 },
  { "GDO_DECL bool gdo_load_lib(void);", 0, 1 },
  { "GDO_DECL bool gdo_load_lib_and_symbols(void);", 0, 1 },
  { "#endif", 0, 1 },
  { "GDO_DECL bool gdo_load_lib_name(const gdo_char_t *filename);", 0, 1 },
  { "GDO_DECL bool gdo_load_lib_name_and_symbols(const gdo_char_t *filename);", 0, 1 },
  { "GDO_DECL bool gdo_load_lib_args(const gdo_char_t *filename, int flags, bool new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "GDO_DECL bool gdo_lib_is_loaded(void);", 0, 1 },
  { "GDO_DECL bool gdo_free_lib(void);", 0, 1 },
  { "", 0, 1 },
  { "GDO_DECL bool gdo_all_symbols_loaded(void);", 0, 1 },
  { "GDO_DECL bool gdo_no_symbols_loaded(void);", 0, 1 },
  { "GDO_DECL bool gdo_any_symbol_loaded(void);", 0, 1 },
  { "GDO_DECL bool gdo_load_all_symbols(void);", 0, 1 },
  { "GDO_DECL bool gdo_load_symbol(int symbol_num);", 0, 1 },
  { "GDO_DECL bool gdo_load_symbol_name(const char *symbol);", 0, 1 },
  { "", 0, 1 },
  { "GDO_DECL const gdo_char_t *gdo_last_error(void);", 0, 1 },
  { "GDO_DECL gdo_char_t *gdo_lib_origin(void);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* enumeration values for gdo_load_symbol() */", 0, 1 },
  { "enum {", 0, 1 },
  { "    GDO_LOAD_%%symbol%%,", 1, 1 },
  { "    GDO_ENUM_LAST", 0, 1 },
  { "};", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* prefixed aliases, useful if GDO_DISABLE_ALIASING was defined */", 0, 1 },
  { "#define GDO_ALIAS_%%func_symbol_pad%% gdo_hndl.ptr.%%func_symbol%%", 1, 1 },
  { "#define GDO_ALIAS_%%obj_symbol_pad%% *gdo_hndl.ptr.%%obj_symbol%%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* disable aliasing if we saved into separate files and the", 0, 1 },
  { " * header file was included from the body file */", 0, 1 },
  { "#if defined(GDO_SEPARATE) && !defined(GDO_INCLUDED_IN_BODY)", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw function pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "#define %%func_symbol_pad%% GDO_ALIAS_%%func_symbol%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw object pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING)", 0, 1 },
  { "#define %%obj_symbol_pad%% GDO_ALIAS_%%obj_symbol%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#endif //GDO_SEPARATE && !GDO_INCLUDED_IN_BODY", 0, 1 },
  { "", 0, 1 },
  { NULL, 0, 0 }
};

/* c.c */
static constexpr template_t c_body[] = {
  { "#line 1 \"<built-in>/c.c\"", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                           C API implementation                            */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "#if defined _MSC_VER && defined(GDO_USE_MESSAGE_BOX)", 0, 1 },
  { "# pragma comment(lib, \"user32.lib\")", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "# include <assert.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef _AIX", 0, 1 },
  { "# include <errno.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "#include <stdarg.h>", 0, 1 },
  { "#include <stdio.h>", 0, 1 },
  { "#include <stdlib.h>", 0, 1 },
  { "#include <string.h>", 0, 1 },
  { "", 0, 1 },
  { "#if defined(GDO_WINAPI) && defined(_UNICODE)", 0, 1 },
  { "# define GDO_XS   L\"%ls\"", 1, 1 },
  { "# define GDO_XHS  L\"%hs\"", 1, 1 },
  { "#else", 0, 1 },
  { "# define GDO_XS   \"%s\"", 1, 1 },
  { "# define GDO_XHS  \"%s\"", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef _T", 0, 1 },
  { "# define _T(x) x", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef _ftprintf", 0, 1 },
  { "# define _ftprintf fprintf", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifndef _countof", 0, 1 },
  { "# define _countof(array) (sizeof(array) / sizeof(array[0]))", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#define GDO_INLINE  static inline", 0, 1 },
  { "", 0, 1 },
  { "#define GDO_SNPRINTF(dst, fmt, ...) \\", 0, 1 },
  { "    gdo_snprintf(dst, _countof(dst), fmt, __VA_ARGS__)", 0, 1 },
  { "", 0, 1 },
  { "#define GDO_STRLCPY(dst, src) \\", 0, 1 },
  { "    gdo_strlcpy(dst, src, _countof(dst))", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* typedefs */", 0, 1 },
  { "typedef void GDO_UNUSED_REF;", 0, 1 },
  { "typedef void GDO_UNUSED_RESULT;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* library handle */", 0, 1 },
  { "GDO_OBJ_LINKAGE gdo_handle_t gdo_hndl;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* forward declarations */", 0, 1 },
  { "GDO_INLINE void gdo_load_library(const gdo_char_t *filename, int flags, bool new_namespace);", 0, 1 },
  { "GDO_INLINE void gdo_register_free_lib(void);", 0, 1 },
  { "GDO_INLINE void *gdo_sym(const char *symbol, const gdo_char_t *msg);", 0, 1 },
  { "#if !defined(GDO_WINAPI) && !defined(GDO_HAVE_DLINFO)", 0, 1 },
  { "GDO_INLINE char *gdo_dladdr_get_fname(const void *ptr);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                                save error                                 */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "/* like snprintf(3), no return value */", 0, 1 },
  { "GDO_INLINE void gdo_snprintf(gdo_char_t *str, size_t size, const gdo_char_t *fmt, ...)", 0, 1 },
  { "{", 0, 1 },
  { "    va_list ap;", 0, 1 },
  { "", 0, 1 },
  { "    va_start(ap, fmt);", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "    _vsntprintf_s(str, size, _TRUNCATE, fmt, ap);", 0, 1 },
  { "#else", 0, 1 },
  { "    vsnprintf(str, size, fmt, ap);", 0, 1 },
  { "#endif", 0, 1 },
  { "    va_end(ap);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* like strlcpy(3), no return value */", 0, 1 },
  { "GDO_INLINE void gdo_strlcpy(gdo_char_t *dst, const gdo_char_t *src, size_t size)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_char_t *end = dst + size - 1;", 0, 1 },
  { "", 0, 1 },
  { "    for ( ; dst != end; dst++, src++) {", 0, 1 },
  { "        *dst = *src;", 0, 1 },
  { "", 0, 1 },
  { "        if (*src == 0) {", 0, 1 },
  { "            return;", 0, 1 },
  { "        }", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    *end = 0;", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* save message to error buffer */", 0, 1 },
  { "GDO_INLINE void gdo_save_to_errbuf(const gdo_char_t *msg)", 0, 1 },
  { "{", 0, 1 },
  { "    if (msg) {", 0, 1 },
  { "        GDO_STRLCPY(gdo_hndl.buf, msg);", 0, 1 },
  { "    }", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "/* Clear error buffers. */", 0, 1 },
  { "GDO_INLINE void gdo_clear_errbuf(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_hndl.buf[0] = 0;", 0, 1 },
  { "    gdo_hndl.buf_formatted[0] = 0;", 0, 1 },
  { "    gdo_hndl.last_errno = 0;", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* Save the last system error code. A message for additional information", 0, 1 },
  { " * can be provided too. */", 0, 1 },
  { "GDO_INLINE void gdo_save_GetLastError(const gdo_char_t *msg)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "    gdo_hndl.last_errno = GetLastError();", 0, 1 },
  { "    gdo_save_to_errbuf(msg);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* Sets the \"no library was loaded\" error message */", 0, 1 },
  { "GDO_INLINE void gdo_set_error_no_library_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "    gdo_hndl.last_errno = ERROR_INVALID_HANDLE;", 0, 1 },
  { "    gdo_save_to_errbuf(_T(\"no library was loaded\"));", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#else", 0, 1 },
  { "/*********************************** dlfcn ***********************************/", 0, 1 },
  { "", 0, 1 },
  { "/* Clear error buffers. */", 0, 1 },
  { "GDO_INLINE void gdo_clear_errbuf(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_hndl.buf[0] = 0;", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* Save the last message provided by dlerror() */", 0, 1 },
  { "GDO_INLINE void gdo_save_dlerror(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "    gdo_save_to_errbuf(dlerror());", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* Sets the \"no library was loaded\" error message */", 0, 1 },
  { "GDO_INLINE void gdo_set_error_no_library_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "    gdo_save_to_errbuf(\"no library was loaded\");", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#endif //!GDO_WINAPI", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                load default library with default flags                    */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "#ifdef GDO_DEFAULT_LIB", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_lib(void)", 0, 1 },
  { "{", 0, 1 },
  { "    return gdo_load_lib_args(GDO_DEFAULT_LIB, GDO_DEFAULT_FLAGS, false);", 0, 1 },
  { "}", 0, 1 },
  { "#endif", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*       load default library with default flags and load the symbols        */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "#ifdef GDO_DEFAULT_LIB", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_lib_and_symbols(void)", 0, 1 },
  { "{", 0, 1 },
  { "    return (gdo_load_lib_args(GDO_DEFAULT_LIB, GDO_DEFAULT_FLAGS, false) &&", 0, 1 },
  { "        gdo_load_all_symbols());", 0, 1 },
  { "}", 0, 1 },
  { "#endif", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*            load library by filename with default flags                    */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_lib_name(const gdo_char_t *filename)", 0, 1 },
  { "{", 0, 1 },
  { "    return gdo_load_lib_args(filename, GDO_DEFAULT_FLAGS, false);", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*     load library by filename with default flags and load the symbols      */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_lib_name_and_symbols(const gdo_char_t *filename)", 0, 1 },
  { "{", 0, 1 },
  { "    return (gdo_load_lib_name(filename) && gdo_load_all_symbols());", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                          load the library                                 */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_lib_args(const gdo_char_t *filename, int flags, bool new_namespace)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    /* check if the library was already loaded */", 0, 1 },
  { "    if (gdo_lib_is_loaded()) {", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    /* empty filename */", 0, 1 },
  { "    if (!filename || *filename == 0) {", 0, 1 },
  { "        gdo_clear_errbuf();", 0, 1 },
  { "        gdo_hndl.last_errno = ERROR_INVALID_NAME;", 0, 1 },
  { "        gdo_save_to_errbuf(_T(\"empty filename\"));", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    gdo_load_library(filename, flags, new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_save_GetLastError(filename);", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#else /* dlfcn */", 0, 1 },
  { "", 0, 1 },
  { "    /* an empty filename will actually return a handle to the main program,", 0, 1 },
  { "     * but we don't want that */", 0, 1 },
  { "    if (!filename || *filename == 0) {", 0, 1 },
  { "        gdo_clear_errbuf();", 0, 1 },
  { "        gdo_save_to_errbuf(\"empty filename\");", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef _AIX", 0, 1 },
  { "    errno = 0;", 0, 1 },
  { "    gdo_load_library(filename, flags, new_namespace);", 0, 1 },
  { "    int errsav = errno;", 0, 1 },
  { "", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_clear_errbuf();", 0, 1 },
  { "        const char *ptr = (errsav == ENOEXEC) ? dlerror() : strerror(errsav);", 0, 1 },
  { "        gdo_save_to_errbuf(ptr);", 0, 1 },
  { "    }", 0, 1 },
  { "#else", 0, 1 },
  { "    gdo_load_library(filename, flags, new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_save_dlerror();", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "#endif //!_AIX", 0, 1 },
  { "", 0, 1 },
  { "#endif //!GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    gdo_register_free_lib();", 0, 1 },
  { "", 0, 1 },
  { "    return true;", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* call LoadLibraryEx/dlopen/dlmopen */", 0, 1 },
  { "GDO_INLINE void gdo_load_library(const gdo_char_t *filename, int flags, bool new_namespace)", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    (GDO_UNUSED_REF) new_namespace;", 0, 1 },
  { "    gdo_hndl.handle = LoadLibraryEx(filename, NULL, flags);", 0, 1 },
  { "", 0, 1 },
  { "#elif defined(GDO_HAVE_DLMOPEN)", 0, 1 },
  { "", 0, 1 },
  { "    /* call dlmopen() for new namespace, otherwise dlopen() */", 0, 1 },
  { "    if (new_namespace) {", 0, 1 },
  { "        gdo_hndl.handle = dlmopen(LM_ID_NEWLM, filename, flags);", 0, 1 },
  { "    } else {", 0, 1 },
  { "        gdo_hndl.handle = dlopen(filename, flags);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#else", 0, 1 },
  { "", 0, 1 },
  { "    /* no dlmopen() */", 0, 1 },
  { "    (GDO_UNUSED_REF) new_namespace;", 0, 1 },
  { "    gdo_hndl.handle = dlopen(filename, flags);", 0, 1 },
  { "", 0, 1 },
  { "#endif //!GDO_WINAPI", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* If registered with atexit() this function will be called at", 0, 1 },
  { " * the program's exit. Function must be of type \"void (*)(void)\". */", 0, 1 },
  { "#ifdef GDO_AUTO_RELEASE", 0, 1 },
  { "GDO_INLINE void gdo_call_free_lib(void)", 0, 1 },
  { "{", 0, 1 },
  { "    if (gdo_lib_is_loaded()) {", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "        FreeLibrary(gdo_hndl.handle);", 0, 1 },
  { "#else", 0, 1 },
  { "        dlclose(gdo_hndl.handle);", 0, 1 },
  { "#endif", 0, 1 },
  { "    }", 0, 1 },
  { "}", 0, 1 },
  { "#endif //GDO_AUTO_RELEASE", 0, 1 },
  { "", 0, 1 },
  { "/* register our call to free the library handle with atexit()", 0, 1 },
  { " * so that the library will automatically be freed upon exit */", 0, 1 },
  { "GDO_INLINE void gdo_register_free_lib(void)", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef GDO_AUTO_RELEASE", 0, 1 },
  { "    if (!gdo_hndl.call_free_lib_is_registered) {", 0, 1 },
  { "        atexit(gdo_call_free_lib);", 0, 1 },
  { "        gdo_hndl.call_free_lib_is_registered = true;", 0, 1 },
  { "    }", 0, 1 },
  { "#endif", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                whether the library is currently loaded                    */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_lib_is_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    return (gdo_hndl.handle != NULL);", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*          Free the library handle and set pointers to NULL                 */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_free_lib(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        /* nothing to free */", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    if (FreeLibrary(gdo_hndl.handle) == FALSE) {", 0, 1 },
  { "        gdo_save_GetLastError(_T(\"FreeLibrary()\"));", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "#else", 0, 1 },
  { "    if (dlclose(gdo_hndl.handle) != 0) {", 0, 1 },
  { "        gdo_save_dlerror();", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    /* set pointers back to NULL */", 0, 1 },
  { "    gdo_hndl.handle = NULL;", 0, 1 },
  { "    gdo_hndl.ptr.%%symbol%% = NULL;", 1, 1 },
  { "", 0, 1 },
  { "    return true;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                    check if ALL symbols were loaded                       */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_all_symbols_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    if (true", 0, 1 },
  { "        && gdo_hndl.ptr.%%symbol%% != NULL", 1, 1 },
  { "    ) {", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return false;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                    check if NO symbols were loaded                        */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_no_symbols_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    if (true", 0, 1 },
  { "        && gdo_hndl.ptr.%%symbol%% == NULL", 1, 1 },
  { "    ) {", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return false;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                     check if ANY symbol was loaded                        */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_any_symbol_loaded(void)", 0, 1 },
  { "{", 0, 1 },
  { "    if (false", 0, 1 },
  { "        || gdo_hndl.ptr.%%symbol%% != NULL", 1, 1 },
  { "    ) {", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return false;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                             load all symbols                              */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_all_symbols(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    /* already loaded all symbols */", 0, 1 },
  { "    if (gdo_all_symbols_loaded()) {", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    /* no library was loaded */", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_set_error_no_library_loaded();", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    /* get symbol addresses */", 0, 1 },
  { "", 0, 1 },
  { "    /* %%symbol%% */\n" /* multiline entry */
    "    if ((gdo_hndl.ptr.%%symbol%% =\n"
    "            (%%sym_type%%)\n"
    "                gdo_sym(\"%%symbol%%\", _T(\"%%symbol%%\"))) == NULL) {\n"
    "        return false;\n"
    "    }\n"
    "", 1, 7 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    return gdo_all_symbols_loaded();", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "GDO_INLINE void *gdo_sym(const char *symbol, const gdo_char_t *msg)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    void *ptr = (void *)GetProcAddress(gdo_hndl.handle, symbol);", 0, 1 },
  { "", 0, 1 },
  { "    if (!ptr) {", 0, 1 },
  { "        gdo_save_GetLastError(msg);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#else", 0, 1 },
  { "", 0, 1 },
  { "    (GDO_UNUSED_REF) msg;", 0, 1 },
  { "", 0, 1 },
  { "    void *ptr = dlsym(gdo_hndl.handle, symbol);", 0, 1 },
  { "", 0, 1 },
  { "    if (!ptr) {", 0, 1 },
  { "        gdo_save_dlerror();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#endif //!GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    return ptr;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                        load a specific symbol                             */", 0, 1 },
  { "/*                                                                           */", 0, 1 },
  { "/* The main intention is to check if a certain symbol is present in a        */", 0, 1 },
  { "/* library so that you can conditionally enable or disable features.         */", 0, 1 },
  { "/* `symbol_num' is an enumeration value `GDO_LOAD_<symbol_name>'             */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_symbol(int symbol_num)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    /* no library was loaded */", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_set_error_no_library_loaded();", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    switch (symbol_num)", 0, 1 },
  { "    {", 0, 1 },
  { "    /* %%symbol%% */\n" /* multiline entry */
    "    case GDO_LOAD_%%symbol%%:\n"
    "        gdo_hndl.ptr.%%symbol%% =\n"
    "            (%%sym_type%%)\n"
    "                gdo_sym(\"%%symbol%%\", _T(\"%%symbol%%\"));\n"
    "        return (gdo_hndl.ptr.%%symbol%% != NULL);\n"
    "", 1, 7 },
  { "    default:", 0, 1 },
  { "        break;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    gdo_hndl.last_errno = ERROR_NOT_FOUND;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    GDO_SNPRINTF(gdo_hndl.buf, _T(\"unknown symbol number: %d\"), symbol_num);", 1, 1 },
  { "", 0, 1 },
  { "    return false;", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                    load a specific symbol by name                         */", 0, 1 },
  { "/*                                                                           */", 0, 1 },
  { "/* The main intention is to check if a certain symbol is present in a        */", 0, 1 },
  { "/* library so that you can conditionally enable or disable features.         */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE bool gdo_load_symbol_name(const char *symbol)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    /* no library was loaded */", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_set_error_no_library_loaded();", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    if (!symbol || *symbol == 0) {", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "        gdo_hndl.last_errno = ERROR_INVALID_PARAMETER;", 0, 1 },
  { "#endif", 0, 1 },
  { "        gdo_save_to_errbuf(_T(\"empty symbol name\"));", 0, 1 },
  { "    } else {", 0, 1 },
  { "        /* jumps to `GDO_JUMP_<..>' label if symbol was found */", 0, 1 },
  { "        GDO_CHECK_SYMBOL_NAME(symbol);", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "        gdo_hndl.last_errno = ERROR_NOT_FOUND;", 0, 1 },
  { "#endif", 0, 1 },
  { "        GDO_SNPRINTF(gdo_hndl.buf, _T(\"unknown symbol: %s\"), symbol);", 1, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return false;", 0, 1 },
  { "", 0, 1 },
  { "    /* jump labels */", 0, 1 },
  { "\n" /* multiline entry */
    "    /* %%symbol%% */\n"
    "GDO_JUMP_%%symbol%%:\n"
    "    gdo_hndl.ptr.%%symbol%% =\n"
    "        (%%sym_type%%)\n"
    "            gdo_sym(\"%%symbol%%\", _T(\"%%symbol%%\"));\n"
    "    return (gdo_hndl.ptr.%%symbol%% != NULL);", 1, 7 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/* retrieve the last saved error message (can be an empty buffer)            */", 0, 1 },
  { "/*                                                                           */", 0, 1 },
  { "/* For WinAPI the message will be generated from an error code.              */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE const gdo_char_t *gdo_last_error(void)", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    /* message was already saved */", 0, 1 },
  { "    if (gdo_hndl.buf_formatted[0] != 0) {", 0, 1 },
  { "        return gdo_hndl.buf_formatted;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    gdo_char_t *buf = NULL;", 0, 1 },
  { "    gdo_char_t *msg = gdo_hndl.buf;", 0, 1 },
  { "", 0, 1 },
  { "    /* format the message */", 0, 1 },
  { "    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |", 0, 1 },
  { "                  FORMAT_MESSAGE_FROM_SYSTEM |", 0, 1 },
  { "                  FORMAT_MESSAGE_MAX_WIDTH_MASK,", 0, 1 },
  { "                  NULL, gdo_hndl.last_errno, 0, (LPTSTR)&buf, 0, NULL);", 0, 1 },
  { "", 0, 1 },
  { "    if (buf) {", 0, 1 },
  { "        /* put custom message in front of system error message */", 0, 1 },
  { "        if (msg[0] != 0 && (_tcslen(buf) + _tcslen(msg) + 2) < _countof(gdo_hndl.buf_formatted)) {", 0, 1 },
  { "            GDO_SNPRINTF(gdo_hndl.buf_formatted, GDO_XS _T(\": \") GDO_XS, msg, buf);", 0, 1 },
  { "        } else {", 0, 1 },
  { "            GDO_STRLCPY(gdo_hndl.buf_formatted, buf);", 0, 1 },
  { "        }", 0, 1 },
  { "        LocalFree(buf);", 0, 1 },
  { "    } else {", 0, 1 },
  { "        /* FormatMessage() failed, save the error code */", 0, 1 },
  { "        GDO_SNPRINTF(gdo_hndl.buf_formatted, _T(\"Last saved error code: %lu\"), gdo_hndl.last_errno);", 1, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return gdo_hndl.buf_formatted;", 0, 1 },
  { "#else", 0, 1 },
  { "    /* simply return the buffer */", 0, 1 },
  { "    return gdo_hndl.buf;", 0, 1 },
  { "#endif //GDO_WINAPI", 0, 1 },
  { "}", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                       get the full library path                           */", 0, 1 },
  { "/*                                                                           */", 0, 1 },
  { "/* Result must be deallocated with free(), returns NULL on error.            */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "GDO_LINKAGE gdo_char_t *gdo_lib_origin(void)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_clear_errbuf();", 0, 1 },
  { "", 0, 1 },
  { "    /* check if library was loaded */", 0, 1 },
  { "    if (!gdo_lib_is_loaded()) {", 0, 1 },
  { "        gdo_set_error_no_library_loaded();", 0, 1 },
  { "        return NULL;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    gdo_char_t *origin;", 0, 1 },
  { "    DWORD len = 260; /* MAX_PATH */", 0, 1 },
  { "", 0, 1 },
  { "    /* allocate enough space */", 0, 1 },
  { "    origin = (gdo_char_t *)malloc(len * sizeof(gdo_char_t));", 0, 1 },
  { "    assert(origin != NULL);", 0, 1 },
  { "", 0, 1 },
  { "    /* receive path from handle */", 0, 1 },
  { "    if (GetModuleFileName(gdo_hndl.handle, origin, len-1) == 0) {", 0, 1 },
  { "        gdo_save_GetLastError(_T(\"GetModuleFileName\"));", 0, 1 },
  { "        free(origin);", 0, 1 },
  { "        return NULL;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    /* https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation", 0, 1 },
  { "     * technically the path could exceed 260 characters, but in reality", 0, 1 },
  { "     * it's practically still stuck at the old MAX_PATH value */", 0, 1 },
  { "    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {", 0, 1 },
  { "        len = 32*1024;", 0, 1 },
  { "        origin = (gdo_char_t *)realloc(origin, len * sizeof(gdo_char_t));", 0, 1 },
  { "        assert(origin != NULL);", 0, 1 },
  { "", 0, 1 },
  { "        if (GetModuleFileName(gdo_hndl.handle, origin, len-1) == 0) {", 0, 1 },
  { "            gdo_save_GetLastError(_T(\"GetModuleFileName\"));", 0, 1 },
  { "            free(origin);", 0, 1 },
  { "            return NULL;", 0, 1 },
  { "        }", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return origin;", 0, 1 },
  { "#elif defined(GDO_HAVE_DLINFO)", 0, 1 },
  { "    /* use dlinfo() to get a link map */", 0, 1 },
  { "    struct link_map *lm = NULL;", 0, 1 },
  { "", 0, 1 },
  { "    if (dlinfo(gdo_hndl.handle, RTLD_DI_LINKMAP, &lm) == -1) {", 0, 1 },
  { "        gdo_save_dlerror();", 0, 1 },
  { "        return NULL;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return lm->l_name ? strdup(lm->l_name) : NULL;", 0, 1 },
  { "#else", 0, 1 },
  { "    /* use dladdr() to get the library path from a symbol pointer */", 0, 1 },
  { "    char *fname;", 0, 1 },
  { "", 0, 1 },
  { "    if (gdo_no_symbols_loaded()) {", 0, 1 },
  { "        gdo_save_to_errbuf(\"no symbols were loaded\");", 0, 1 },
  { "        return NULL;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    fname = gdo_dladdr_get_fname((void *)gdo_hndl.ptr.%%symbol%%);\n" /* multiline entry */
    "    if (fname) return fname;", 1, 2 },
  { "", 0, 1 },
  { "    gdo_save_to_errbuf(\"dladdr() failed to get library path\");", 0, 1 },
  { "", 0, 1 },
  { "    return NULL;", 0, 1 },
  { "#endif //GDO_WINAPI", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_WINAPI) && !defined(GDO_HAVE_DLINFO)", 0, 1 },
  { "GDO_INLINE char *gdo_dladdr_get_fname(const void *ptr)", 0, 1 },
  { "{", 0, 1 },
  { "    Dl_info info;", 0, 1 },
  { "", 0, 1 },
  { "    if (ptr && dladdr(ptr, &info) != 0 && info.dli_fname) {", 0, 1 },
  { "        return strdup(info.dli_fname);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    return NULL;", 0, 1 },
  { "}", 0, 1 },
  { "#endif // !GDO_WINAPI && !GDO_HAVE_DLINFO", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "%PARAM_SKIP_REMOVE_BEGIN%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                                wrap code                                  */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "", 0, 1 },
  { "#ifndef GDO_HOOK_%%func_symbol%%\n" /* multiline entry */
    "#define GDO_HOOK_%%func_symbol%%(...) /**/\n"
    "#endif", 1, 3 },
  { "", 0, 1 },
  { "#if defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "GDO_INLINE void gdo_error_exit(const gdo_char_t *msg)", 0, 1 },
  { "{", 0, 1 },
  { "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)", 0, 1 },
  { "    MessageBox(NULL, msg, _T(\"Error\"), MB_OK | MB_ICONERROR);", 0, 1 },
  { "#else", 0, 1 },
  { "    _ftprintf(stderr, GDO_XS _T(\"\\n\"), msg);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    gdo_free_lib();", 0, 1 },
  { "    exit(1);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* function wrappers (functions with `...' arguments are omitted) */", 0, 1 },
  { "", 0, 1 },
  { "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n" /* multiline entry */
    "    if (!gdo_hndl.ptr.%%func_symbol%%) {\n"
    "        gdo_error_exit(\"error: symbol `%%func_symbol%%' was not loaded\");\n"
    "    }\n"
    "    GDO_HOOK_%%func_symbol%%(%%notype_args%%);\n"
    "    %%return%% gdo_hndl.ptr.%%func_symbol%%(%%notype_args%%);\n"
    "}\n"
    "", 1, 8 },
  { "", 0, 1 },
  { "#elif defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)", 0, 1 },
  { "/* Windows: show message in a MessageBox window */", 0, 1 },
  { "GDO_INLINE void gdo_win32_last_error_messagebox(const gdo_char_t *symbol)", 0, 1 },
  { "{", 0, 1 },
  { "    const gdo_char_t *fmt = _T(\"error in wrapper function for symbol\")", 0, 1 },
  { "        _T(\"`\") GDO_XS _T(\"':\\n\\n\") GDO_XS;", 0, 1 },
  { "", 0, 1 },
  { "    const gdo_char_t *err = gdo_last_error();", 0, 1 },
  { "", 0, 1 },
  { "    const size_t buflen = _tcslen(fmt) + _tcslen(symbol) + _tcslen(err) + 1;", 0, 1 },
  { "    gdo_char_t *buf = (gdo_char_t *)malloc(buflen * sizeof(gdo_char_t));", 0, 1 },
  { "    assert(buf != NULL);", 0, 1 },
  { "", 0, 1 },
  { "    gdo_snprintf(buf, buflen, fmt, symbol, err);", 0, 1 },
  { "    MessageBox(NULL, buf, _T(\"Error\"), MB_OK | MB_ICONERROR);", 0, 1 },
  { "", 0, 1 },
  { "    free(buf);", 0, 1 },
  { "}", 0, 1 },
  { "#endif //_WIN32 && GDO_USE_MESSAGE_BOX", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* This function is used by the wrapper functions to perform the loading", 0, 1 },
  { " * and handle errors. */", 0, 1 },
  { "GDO_INLINE void gdo_quick_load(int symbol_num, const gdo_char_t *symbol)", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef GDO_DELAYLOAD", 0, 1 },
  { "    /* load library + requested symbol */", 0, 1 },
  { "    if (gdo_load_lib() && gdo_load_symbol(symbol_num)) {", 0, 1 },
  { "        return;", 0, 1 },
  { "    }", 0, 1 },
  { "#else", 0, 1 },
  { "    (GDO_UNUSED_REF) symbol_num;", 0, 1 },
  { "", 0, 1 },
  { "    /* return immediately if everything is already loaded,", 0, 1 },
  { "     * otherwise load library + all symbols */", 0, 1 },
  { "    if (gdo_all_symbols_loaded() || gdo_load_lib_and_symbols()) {", 0, 1 },
  { "        return;", 0, 1 },
  { "    }", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    /* an error has occured: display an error message */", 0, 1 },
  { "", 0, 1 },
  { "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)", 0, 1 },
  { "    /* Windows: popup message box window */", 0, 1 },
  { "    gdo_win32_last_error_messagebox(symbol);", 0, 1 },
  { "#else", 0, 1 },
  { "    _ftprintf(stderr, _T(\"error in wrapper function for symbol `\") GDO_XS _T(\"':\\n\")", 0, 1 },
  { "        GDO_XS _T(\"\\n\"), symbol, gdo_last_error());", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    /* free library handle and exit */", 0, 1 },
  { "    gdo_free_lib();", 0, 1 },
  { "    exit(1);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* autoload function wrappers (functions with `...' arguments are omitted) */", 0, 1 },
  { "", 0, 1 },
  { "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n" /* multiline entry */
    "    gdo_quick_load(GDO_LOAD_%%func_symbol%%, _T(\"%%func_symbol%%\"));\n"
    "    GDO_HOOK_%%func_symbol%%(%%notype_args%%);\n"
    "    %%return%% gdo_hndl.ptr.%%func_symbol%%(%%notype_args%%);\n"
    "}\n"
    "", 1, 6 },
  { "#endif //GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "/***************************** end of wrap code ******************************/", 0, 1 },
  { "%PARAM_SKIP_END%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_SEPARATE) /* single header file */", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw function pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "#define %%func_symbol_pad%% GDO_ALIAS_%%func_symbol%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw object pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING)", 0, 1 },
  { "#define %%obj_symbol_pad%% GDO_ALIAS_%%obj_symbol%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#endif //!GDO_SEPARATE", 0, 1 },
  { "", 0, 1 },
  { NULL, 0, 0 }
};

/* cxx.hpp */
static constexpr template_t cxx_header[] = {
  { "#line 1 \"<built-in>/cxx.hpp\"", 0, 1 },
  { "#if 0", 0, 1 },
  { "", 0, 1 },
  { "/* summary */", 0, 1 },
  { "", 0, 1 },
  { "namespace gdo", 0, 1 },
  { "{", 0, 1 },
  { "", 0, 1 },
  { "/* default flags */", 0, 1 },
  { "constexpr const int default_flags;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").", 0, 1 },
  { " * Useful i.e. on plugins. */", 0, 1 },
  { "static constexpr const char * const libext;", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "constexpr const wchar_t * const libext_w;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Create versioned library names for DLLs, dylibs and DSOs.", 0, 1 },
  { " * make_libname(\"z\",1) for example will return \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\" */", 0, 1 },
  { "std::string make_libname(const std::string &name, const size_t api);", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "std::wstring make_libname(const std::wstring &name, const size_t api);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "class dl", 0, 1 },
  { "{", 0, 1 },
  { "public:", 0, 1 },
  { "", 0, 1 },
  { "    using message_callback_t = void (*)(const char *);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* c'tor */", 0, 1 },
  { "    dl();", 0, 1 },
  { "    dl(const std::string &filename, int flags=default_flags, bool new_namespace=false);", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    dl(const std::wstring &filename, int flags=default_flags, bool new_namespace=false);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* d'tor */", 0, 1 },
  { "    ~dl();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load the library; `filename' and `flags' are passed to the underlying library", 0, 1 },
  { "     * loading functions.", 0, 1 },
  { "     *", 0, 1 },
  { "     * If `new_namespace' is true the library will be loaded into a new namespace.", 0, 1 },
  { "     * This is done using dlmopen() (if available on the platform) with the", 0, 1 },
  { "     * LM_ID_NEWLM argument. */", 0, 1 },
  { "    bool load(const std::string &filename, int flags=default_flags, bool new_namespace=false);", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    bool load(const std::wstring &filename, int flags=default_flags, bool new_namespace=false);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load the library.", 0, 1 },
  { "     * Filename and flags must have been set with the the constructor. */", 0, 1 },
  { "    bool load();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load library from a list.", 0, 1 },
  { "     * T should be of a container type like std::vector, std::list, std::array, ... */", 0, 1 },
  { "    bool load_from_list(const T &list, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load library and symbols.", 0, 1 },
  { "     * Filename and flags must have been set with the the constructor. */", 0, 1 },
  { "    bool load_lib_and_symbols();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if the library is loaded */", 0, 1 },
  { "    bool lib_loaded();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* return the flags used to load the library */", 0, 1 },
  { "    int flags();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load the symbols. This function can safely be called multiple times.", 0, 1 },
  { "     * If ignore_errors is set true the function won't stop on the first", 0, 1 },
  { "     * symbol that can't be loaded but instead tries to load them all.", 0, 1 },
  { "     * If one or more symbols weren't loaded the function returns false. */", 0, 1 },
  { "    bool load_all_symbols(bool ignore_errors=false);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Load a specific symbol.", 0, 1 },
  { "     * `symbol_num' is an enumeration value: `GDO_LOAD_<symbol_name>' */", 0, 1 },
  { "    bool load_symbol(int symbol_num);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if ALL symbols were loaded */", 0, 1 },
  { "    bool all_symbols_loaded();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if NO symbols were loaded */", 0, 1 },
  { "    bool no_symbols_loaded();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if ANY symbol was loaded */", 0, 1 },
  { "    bool any_symbol_loaded();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* free library */", 0, 1 },
  { "    bool free();", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* whether to free the library in the class destructor */", 0, 1 },
  { "    void free_lib_in_dtor(bool b);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if defined(GDO_WRAP_FUNCTIONS) || defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "", 0, 1 },
  { "    /* Set a message callback function to be used if an error occurred", 0, 1 },
  { "     * in a wrapped function. */", 0, 1 },
  { "    static void message_callback(message_callback_t cb);", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Get a pointer to the message callback function. */", 0, 1 },
  { "    static message_callback_t message_callback();", 0, 1 },
  { "", 0, 1 },
  { "#endif // GDO_WRAP_FUNCTIONS || GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get path of loaded library */", 0, 1 },
  { "    std::string origin();", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    std::wstring origin_w();", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    /* retrieve the last error */", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    std::string error();", 0, 1 },
  { "    std::wstring error_w();", 0, 1 },
  { "#else", 0, 1 },
  { "    std::string error() const;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    /* get filename passed to load */", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    std::string filename();", 0, 1 },
  { "    std::wstring filename_w();", 0, 1 },
  { "#else", 0, 1 },
  { "    std::string filename() const;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "}; /* class */", 0, 1 },
  { "", 0, 1 },
  { "} /* namespace */", 0, 1 },
  { "", 0, 1 },
  { "#endif // 0", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/***", 0, 1 },
  { "", 0, 1 },
  { "****************************************************", 0, 1 },
  { "* The following options may be set through macros: *", 0, 1 },
  { "****************************************************", 0, 1 },
  { "", 0, 1 },
  { "GDO_USE_DLOPEN", 0, 1 },
  { "    If defined `dlopen()' API is used on win32 targets.", 0, 1 },
  { "    On other targets `dlopen()' is always used.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_FLAGS", 0, 1 },
  { "    Override the default flags to use when loading a library.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_LIB", 0, 1 },
  { "    Set a default library name through this macro (including double quote", 0, 1 },
  { "    marks). This macro must be defined if you want to set GDO_ENABLE_AUTOLOAD.", 0, 1 },
  { "", 0, 1 },
  { "GDO_WRAP_FUNCTIONS", 0, 1 },
  { "    Use actual wrapped functions instead of a name alias. This is useful if you", 0, 1 },
  { "    want to create a library to later link an application against.", 0, 1 },
  { "", 0, 1 },
  { "GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "    Define this macro if you want to use auto-loading wrapper functions.", 0, 1 },
  { "    This means you don't need to explicitly call library load functions.", 0, 1 },
  { "    The first wrapper function called will load all symbols at once.", 0, 1 },
  { "    It requires GDO_DEFAULT_LIB to be defined.", 0, 1 },
  { "    If an error occures during loading these functions print an error message", 0, 1 },
  { "    and call `std::exit(1)'!", 0, 1 },
  { "", 0, 1 },
  { "GDO_DELAYLOAD", 0, 1 },
  { "    Same as GDO_ENABLE_AUTOLOAD but only the requested symbol is loaded when its", 0, 1 },
  { "    wrapper function is called instead of all symbols.", 0, 1 },
  { "    It requires GDO_ENABLE_AUTOLOAD to be defined.", 0, 1 },
  { "", 0, 1 },
  { "GDO_VISIBILITY", 0, 1 },
  { "    You can set the symbol visibility of wrapped functions (enabled with", 0, 1 },
  { "    GDO_WRAP_FUNCTIONS) using this macro.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_ALIASING", 0, 1 },
  { "    Don't use preprocessor macros to alias symbol names. Use with care.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_DLINFO", 0, 1 },
  { "    Always disable usage of `dlinfo(3)'.", 0, 1 },
  { "", 0, 1 },
  { "GDO_DISABLE_DLMOPEN", 0, 1 },
  { "    Always disable usage of `dlmopen(3)'.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "*****************", 0, 1 },
  { "* Helper macros *", 0, 1 },
  { "*****************", 0, 1 },
  { "", 0, 1 },
  { "GDO_DEFAULT_FLAGS", 0, 1 },
  { "    Default flags for `dlopen()' or `LoadLibraryEx()'", 0, 1 },
  { "", 0, 1 },
  { "GDO_ALIAS_<symbol>", 0, 1 },
  { "    Convenience macro to access the symbol pointer. I.e. `GDO_ALIAS_helloworld' will", 0, 1 },
  { "    access the pointer to `helloworld'.", 0, 1 },
  { "", 0, 1 },
  { "LIBNAME(NAME, API)", 0, 1 },
  { "LIBNAMEA(NAME, API)", 0, 1 },
  { "LIBNAMEW(NAME, API)", 0, 1 },
  { "    Convenience macro to create versioned library names for DLLs, dylibs and DSOs,", 0, 1 },
  { "    including double quote marks.", 0, 1 },
  { "    LIBNAME(z,1) for example will become \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\".", 0, 1 },
  { "", 0, 1 },
  { "LIBEXT", 0, 1 },
  { "LIBEXTA", 0, 1 },
  { "LIBEXTW", 0, 1 },
  { "    Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").", 0, 1 },
  { "    Useful i.e. on plugins.", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "*********", 0, 1 },
  { "* Hooks *", 0, 1 },
  { "*********", 0, 1 },
  { "", 0, 1 },
  { "GDO_HOOK_<function>(...)", 0, 1 },
  { "    Define a hook macro that will be inserted into a wrap function.", 0, 1 },
  { "    The hook is placed before the actual function call.", 0, 1 },
  { "    If you want to call the function inside the macro you must do so using the GDO_ALIAS_* prefix.", 0, 1 },
  { "    Parameter names are taken from the function prototype declarations (or it's \"a, b, c\" and so on", 0, 1 },
  { "    if the header was created with `-param=create'). A hook may be left undefined.", 0, 1 },
  { "    For example if a function declaration is `int sum_of_a_and_b(int val_a, int val_b)':", 0, 1 },
  { "    #define GDO_HOOK_sum_of_a_and_b(...) \\", 0, 1 },
  { "      printf(\"debug: the sum of %d and %d is %d\\n\", val_a, val_b, GDO_ALIAS_sum_of_a_and_b(__VA_ARGS__));", 1, 1 },
  { "", 0, 1 },
  { "***/", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "# include <cstdlib>", 0, 1 },
  { "# include <cstring>", 0, 1 },
  { "#endif", 0, 1 },
  { "#ifdef _AIX", 0, 1 },
  { "# include <cerrno>", 0, 1 },
  { "# include <cstring>", 0, 1 },
  { "#endif", 0, 1 },
  { "#include <string>", 0, 1 },
  { "", 0, 1 },
  { "#if defined(GDO_WRAP_FUNCTIONS) || defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "# define GDO_HAS_MSG_CB", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* enumeration values for `load_symbol()' method */", 0, 1 },
  { "enum {", 0, 1 },
  { "    GDO_LOAD_%%symbol%%,", 1, 1 },
  { "    GDO_ENUM_LAST", 0, 1 },
  { "};", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "namespace gdo", 0, 1 },
  { "{", 0, 1 },
  { "", 0, 1 },
  { "/* silence `unused' compiler warnings, basically", 0, 1 },
  { " * the same as `#define UNUSED_VAL_(x) (void)x' */", 0, 1 },
  { "template<typename T>", 0, 1 },
  { "void UNUSED_VAL_(T val) {", 0, 1 },
  { "    static_cast<void>(val);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Create versioned library names for DLLs, dylibs and DSOs.", 0, 1 },
  { " * make_libname(\"z\",1) for example will return \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\" */", 0, 1 },
  { "std::string make_libname(const std::string &name, const size_t api);", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "std::wstring make_libname(const std::wstring &name, const size_t api);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* default flags */", 0, 1 },
  { "constexpr const int default_flags = GDO_DEFAULT_FLAGS;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").", 0, 1 },
  { " * Useful i.e. on plugins. */", 0, 1 },
  { "constexpr const char * const libext = LIBEXTA;", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "constexpr const wchar_t * const libext_w = LIBEXTW;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* symbol pointers */", 0, 1 },
  { "namespace ptr {", 0, 1 },
  { "    extern %%type%% (*%%func_symbol%%)(%%args%%);", 1, 1 },
  { "    extern %%obj_type%% *%%obj_symbol%%;", 1, 1 },
  { "};", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "/*                          library loader class                             */", 0, 1 },
  { "/*****************************************************************************/", 0, 1 },
  { "class dl", 0, 1 },
  { "{", 0, 1 },
  { "public:", 0, 1 },
  { "", 0, 1 },
  { "    using message_callback_t = void (*)(const char *);", 0, 1 },
  { "", 0, 1 },
  { "private:", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAS_MSG_CB", 0, 1 },
  { "    /* function pointer to error message callback */", 0, 1 },
  { "    static message_callback_t m_message_callback;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "    std::string m_filename;", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    std::wstring m_wfilename;", 0, 1 },
  { "#endif", 0, 1 },
  { "    int m_flags = default_flags;", 0, 1 },
  { "    bool m_new_namespace = false;", 0, 1 },
  { "    bool m_free_lib_in_dtor = true;", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    T function_cast(FARPROC proc) {", 0, 1 },
  { "        /* cast to void* to supress compiler warnings */", 0, 1 },
  { "        return reinterpret_cast<T>(reinterpret_cast<void *>(proc));", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    /* library handle */", 0, 1 },
  { "    using handle_t = HMODULE;", 0, 1 },
  { "    static handle_t m_handle;", 0, 1 },
  { "", 0, 1 },
  { "    /* error message */", 0, 1 },
  { "    DWORD m_last_error = 0;", 0, 1 },
  { "    std::string m_errmsg;", 0, 1 },
  { "    std::wstring m_werrmsg;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* wstring to string */", 0, 1 },
  { "    static std::string wstr_to_str(const std::wstring &wstr)", 0, 1 },
  { "    {", 0, 1 },
  { "        size_t len, n;", 0, 1 },
  { "        char *buf;", 0, 1 },
  { "        std::string str;", 0, 1 },
  { "", 0, 1 },
  { "        if (wstr.empty()) {", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (::wcstombs_s(&len, nullptr, 0, wstr.c_str(), 0) != 0 || len == 0) {", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        buf = new char[len + 1];", 0, 1 },
  { "        if (!buf) return {};", 0, 1 },
  { "", 0, 1 },
  { "        if (::wcstombs_s(&n, buf, len+1, wstr.c_str(), len) != 0 || n == 0) {", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        buf[len] = '\\0';", 0, 1 },
  { "        str = buf;", 0, 1 },
  { "        delete[] buf;", 0, 1 },
  { "", 0, 1 },
  { "        return str;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* string to wstring */", 0, 1 },
  { "    static std::wstring str_to_wstr(const std::string &str)", 0, 1 },
  { "    {", 0, 1 },
  { "        size_t len, n;", 0, 1 },
  { "        wchar_t *buf;", 0, 1 },
  { "        std::wstring wstr;", 0, 1 },
  { "", 0, 1 },
  { "        if (str.empty()) {", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (::mbstowcs_s(&len, nullptr, 0, str.c_str(), 0) != 0 || len == 0) {", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        buf = new wchar_t[(len + 1) * sizeof(wchar_t)];", 0, 1 },
  { "        if (!buf) return {};", 0, 1 },
  { "", 0, 1 },
  { "        if (::mbstowcs_s(&n, buf, len+1, str.c_str(), len) != 0 || n == 0) {", 0, 1 },
  { "            delete[] buf;", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        buf[len] = L'\\0';", 0, 1 },
  { "        wstr = buf;", 0, 1 },
  { "        delete[] buf;", 0, 1 },
  { "", 0, 1 },
  { "        return wstr;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* clear error */", 0, 1 },
  { "    void clear_error()", 0, 1 },
  { "    {", 0, 1 },
  { "        m_errmsg.clear();", 0, 1 },
  { "        m_werrmsg.clear();", 0, 1 },
  { "        m_last_error = 0;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* save last error (no extra message) */", 0, 1 },
  { "    void save_error()", 0, 1 },
  { "    {", 0, 1 },
  { "        m_last_error = ::GetLastError();", 0, 1 },
  { "        m_errmsg.clear();", 0, 1 },
  { "        m_werrmsg.clear();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* save last error (narrow char message) */", 0, 1 },
  { "    void save_error(const std::string &msg)", 0, 1 },
  { "    {", 0, 1 },
  { "        m_last_error = ::GetLastError();", 0, 1 },
  { "        m_errmsg = msg;", 0, 1 },
  { "        m_werrmsg.clear();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* save last error (wide char message) */", 0, 1 },
  { "    void save_error(const std::wstring &msg)", 0, 1 },
  { "    {", 0, 1 },
  { "        m_last_error = ::GetLastError();", 0, 1 },
  { "        m_errmsg.clear();", 0, 1 },
  { "        m_werrmsg = msg;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* if m_handle is NULL */", 0, 1 },
  { "    void set_error_invalid_handle()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "        m_last_error = ERROR_INVALID_HANDLE;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* if filename is empty */", 0, 1 },
  { "    void set_error_empty_filename()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "        m_last_error = ERROR_INVALID_NAME;", 0, 1 },
  { "        m_errmsg = \"empty filename\";", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library */", 0, 1 },
  { "    void load_lib(const std::string &filename, int flags, bool new_namespace)", 0, 1 },
  { "    {", 0, 1 },
  { "        UNUSED_VAL_(new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "        m_wfilename.clear();", 0, 1 },
  { "        m_filename = filename;", 0, 1 },
  { "        m_flags = flags;", 0, 1 },
  { "", 0, 1 },
  { "        m_handle = ::LoadLibraryExA(filename.c_str(), NULL, m_flags);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library (wide character) */", 0, 1 },
  { "    void load_lib(const std::wstring &filename, int flags, bool new_namespace)", 0, 1 },
  { "    {", 0, 1 },
  { "        UNUSED_VAL_(new_namespace);", 0, 1 },
  { "", 0, 1 },
  { "        m_filename.clear();", 0, 1 },
  { "        m_wfilename = filename;", 0, 1 },
  { "        m_flags = flags;", 0, 1 },
  { "", 0, 1 },
  { "        m_handle = ::LoadLibraryExW(filename.c_str(), NULL, m_flags);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* free library handle */", 0, 1 },
  { "    bool free_lib()", 0, 1 },
  { "    {", 0, 1 },
  { "        return (::FreeLibrary(m_handle) == TRUE);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load symbol address */", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    T sym_load(const char *symbol)", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        T proc = function_cast<T>(::GetProcAddress(m_handle, symbol));", 0, 1 },
  { "", 0, 1 },
  { "        if (!proc) {", 0, 1 },
  { "            save_error(symbol);", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return proc;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    DWORD get_module_filename(HMODULE handle, wchar_t *buf, DWORD len) {", 0, 1 },
  { "        return ::GetModuleFileNameW(handle, buf, len);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    DWORD get_module_filename(HMODULE handle, char *buf, DWORD len) {", 0, 1 },
  { "        return ::GetModuleFileNameA(handle, buf, len);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get the module's full path using GetModuleFileName() */", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    std::basic_string<T> get_origin_from_module_handle()", 0, 1 },
  { "    {", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            set_error_invalid_handle();", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        DWORD len = 260; /* MAX_PATH */", 0, 1 },
  { "        T *origin = new T[len * sizeof(T)]();", 0, 1 },
  { "        ::memset(origin, 0, len * sizeof(T));", 0, 1 },
  { "", 0, 1 },
  { "        if (get_module_filename(m_handle, origin, len-1) == 0) {", 0, 1 },
  { "            save_error();", 0, 1 },
  { "            delete[] origin;", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        /* https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation", 0, 1 },
  { "         * technically the path could exceed 260 characters, but in reality", 0, 1 },
  { "         * it's practically still stuck at the old MAX_PATH value */", 0, 1 },
  { "        if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {", 0, 1 },
  { "            delete[] origin;", 0, 1 },
  { "", 0, 1 },
  { "            len = 32*1024;", 0, 1 },
  { "            origin = new T[len * sizeof(T)]();", 0, 1 },
  { "            ::memset(origin, 0, len * sizeof(T));", 0, 1 },
  { "", 0, 1 },
  { "            if (get_module_filename(m_handle, origin, len-1) == 0) {", 0, 1 },
  { "                save_error();", 0, 1 },
  { "                delete[] origin;", 0, 1 },
  { "                return {};", 0, 1 },
  { "            }", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        std::basic_string<T> str = origin;", 0, 1 },
  { "        delete[] origin;", 0, 1 },
  { "", 0, 1 },
  { "        return str;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    DWORD format_message(DWORD flags, DWORD msgId, LPWSTR buf) {", 0, 1 },
  { "        return ::FormatMessageW(flags, NULL, msgId, 0, buf, 0, NULL);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    DWORD format_message(DWORD flags, DWORD msgId, LPSTR buf) {", 0, 1 },
  { "        return ::FormatMessageA(flags, NULL, msgId, 0, buf, 0, NULL);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* return a formatted error message */", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    std::basic_string<T> format_last_error_message()", 0, 1 },
  { "    {", 0, 1 },
  { "        std::basic_string<T> str;", 0, 1 },
  { "        T *buf = nullptr;", 0, 1 },
  { "", 0, 1 },
  { "        const DWORD flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |", 0, 1 },
  { "                            FORMAT_MESSAGE_FROM_SYSTEM |", 0, 1 },
  { "                            FORMAT_MESSAGE_MAX_WIDTH_MASK;", 0, 1 },
  { "", 0, 1 },
  { "        format_message(flags, m_last_error, reinterpret_cast<T*>(&buf));", 0, 1 },
  { "", 0, 1 },
  { "        if (buf) {", 0, 1 },
  { "            str = buf;", 0, 1 },
  { "            ::LocalFree(buf);", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return str;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#else", 0, 1 },
  { "/*********************************** dlfcn ***********************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* library handle */", 0, 1 },
  { "    using handle_t = void*;", 0, 1 },
  { "    static handle_t m_handle;", 0, 1 },
  { "", 0, 1 },
  { "    /* error message */", 0, 1 },
  { "    std::string m_errmsg;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* clear error */", 0, 1 },
  { "    void clear_error()", 0, 1 },
  { "    {", 0, 1 },
  { "        m_errmsg.clear();", 0, 1 },
  { "        ::dlerror();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* save last error */", 0, 1 },
  { "    void save_error()", 0, 1 },
  { "    {", 0, 1 },
  { "        auto ptr = ::dlerror();", 0, 1 },
  { "        m_errmsg = ptr ? ptr : \"\";", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    void save_error(const std::string&)", 0, 1 },
  { "    {", 0, 1 },
  { "        save_error();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* if m_handle is NULL */", 0, 1 },
  { "    void set_error_invalid_handle()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "        m_errmsg = \"no library was loaded\";", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* if filename is empty */", 0, 1 },
  { "    void set_error_empty_filename()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "        m_errmsg = \"empty filename\";", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library */", 0, 1 },
  { "    void load_lib(const std::string &filename, int flags, bool new_namespace)", 0, 1 },
  { "    {", 0, 1 },
  { "        m_flags = flags;", 0, 1 },
  { "        m_filename = filename;", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAVE_DLMOPEN", 0, 1 },
  { "        /* dlmopen() for new namespace or dlopen() */", 0, 1 },
  { "        if (new_namespace) {", 0, 1 },
  { "            m_handle = ::dlmopen(LM_ID_NEWLM, filename.c_str(), m_flags);", 0, 1 },
  { "        } else {", 0, 1 },
  { "            m_handle = ::dlopen(filename.c_str(), m_flags);", 0, 1 },
  { "        }", 0, 1 },
  { "#else", 0, 1 },
  { "        /* no dlmopen() */", 0, 1 },
  { "        UNUSED_VAL_(new_namespace);", 0, 1 },
  { "        m_handle = ::dlopen(filename.c_str(), m_flags);", 0, 1 },
  { "#endif", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* free library handle */", 0, 1 },
  { "    bool free_lib()", 0, 1 },
  { "    {", 0, 1 },
  { "        return (::dlclose(m_handle) == 0);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load symbol address */", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    T sym_load(const char *symbol)", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        T ptr = reinterpret_cast<T>(::dlsym(m_handle, symbol));", 0, 1 },
  { "", 0, 1 },
  { "        /**", 0, 1 },
  { "        * Linux man page mentions cases where NULL pointer is a valid address.", 0, 1 },
  { "        * These however seem to be edge-cases that are irrelevant to us.", 0, 1 },
  { "        * Furthermore this is contradicting POSIX which says a NULL pointer shall", 0, 1 },
  { "        * be returned on an error.", 0, 1 },
  { "        */", 0, 1 },
  { "        if (!ptr) {", 0, 1 },
  { "            save_error();", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return ptr;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#endif // !GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library by filename */", 0, 1 },
  { "    template<typename T>", 0, 1 },
  { "    bool load_filename(const T &filename, int flags, bool new_namespace)", 0, 1 },
  { "    {", 0, 1 },
  { "        /* release old libhandle */", 0, 1 },
  { "        if (lib_loaded() && !free()) {", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (filename.empty()) {", 0, 1 },
  { "            set_error_empty_filename();", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "#ifdef _AIX", 0, 1 },
  { "        errno = 0;", 0, 1 },
  { "        load_lib(filename, flags, new_namespace);", 0, 1 },
  { "        int errsav = errno;", 0, 1 },
  { "", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            const char *ptr = (errsav == ENOEXEC) ? ::dlerror() : ::strerror(errsav);", 0, 1 },
  { "            m_errmsg = ptr ? ptr : \"\";", 0, 1 },
  { "        }", 0, 1 },
  { "#else", 0, 1 },
  { "        load_lib(filename, flags, new_namespace);", 0, 1 },
  { "        save_error(filename);", 0, 1 },
  { "#endif //!_AIX", 0, 1 },
  { "", 0, 1 },
  { "        return lib_loaded();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "public:", 0, 1 },
  { "", 0, 1 },
  { "    /* c'tor (empty) */", 0, 1 },
  { "    dl()", 0, 1 },
  { "    {}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* c'tor (set filename) */", 0, 1 },
  { "    dl(const std::string &filename, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "      : m_filename(filename),", 0, 1 },
  { "        m_flags(flags),", 0, 1 },
  { "        m_new_namespace(new_namespace)", 0, 1 },
  { "    {}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    /* c'tor (set wide character filename) */", 0, 1 },
  { "    dl(const std::wstring &filename, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "      : m_wfilename(filename),", 0, 1 },
  { "        m_flags(flags)", 0, 1 },
  { "    {", 0, 1 },
  { "        UNUSED_VAL_(new_namespace);", 0, 1 },
  { "    }", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* d'tor */", 0, 1 },
  { "    ~dl()", 0, 1 },
  { "    {", 0, 1 },
  { "        if (m_free_lib_in_dtor && lib_loaded()) {", 0, 1 },
  { "            free_lib();", 0, 1 },
  { "        }", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library */", 0, 1 },
  { "    bool load(const std::string &filename, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "    {", 0, 1 },
  { "        return load_filename(filename, flags, new_namespace);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "    /* load library (wide characters version) */", 0, 1 },
  { "    bool load(const std::wstring &filename, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "    {", 0, 1 },
  { "        return load_filename(filename, flags, new_namespace);", 0, 1 },
  { "    }", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library */", 0, 1 },
  { "    bool load()", 0, 1 },
  { "    {", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "        if (m_filename.empty() && !m_wfilename.empty()) {", 0, 1 },
  { "            return load(m_wfilename, m_flags, m_new_namespace);", 0, 1 },
  { "        }", 0, 1 },
  { "#endif", 0, 1 },
  { "        return load(m_filename, m_flags, m_new_namespace);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load from a container list of filenames (std::vector, std::list, etc.) */", 0, 1 },
  { "    template<class T>", 0, 1 },
  { "    bool load_from_list(const T &list, int flags=default_flags, bool new_namespace=false)", 0, 1 },
  { "    {", 0, 1 },
  { "        for (const auto &e : list) {", 0, 1 },
  { "            if (load(e, flags, new_namespace)) {", 0, 1 },
  { "                return true;", 0, 1 },
  { "            }", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library and symbols */", 0, 1 },
  { "    bool load_lib_and_symbols()", 0, 1 },
  { "    {", 0, 1 },
  { "        return (load() && load_all_symbols());", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if library is loaded */", 0, 1 },
  { "    bool lib_loaded() const", 0, 1 },
  { "    {", 0, 1 },
  { "        return (m_handle != nullptr);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* return the flags used to load the library */", 0, 1 },
  { "    int flags() const", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_flags;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load all symbols */", 0, 1 },
  { "    bool load_all_symbols(bool ignore_errors=false)", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (all_symbols_loaded()) {", 0, 1 },
  { "            return true;", 0, 1 },
  { "        } else if (!lib_loaded()) {", 0, 1 },
  { "            set_error_invalid_handle();", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        /* We can ignore errors in which case dlsym() or GetProcAddress()", 0, 1 },
  { "         * is called for each symbol and continue to do so even if it fails.", 0, 1 },
  { "         * The function will however in the end still return false if 1 or more", 0, 1 },
  { "         * symbols failed to load.", 0, 1 },
  { "         * If we do not ignore errors the function will simply return false on", 0, 1 },
  { "         * the first error it encounters. */", 0, 1 },
  { "", 0, 1 },
  { "        /* get symbol addresses */", 0, 1 },
  { "", 0, 1 },
  { "        /* %%symbol%% */\n" /* multiline entry */
    "        ptr::%%symbol%% =\n"
    "            sym_load<%%sym_type%%>\n"
    "                (\"%%symbol%%\");\n"
    "        if (!ptr::%%symbol%% && !ignore_errors) {\n"
    "            return false;\n"
    "        }\n"
    "", 1, 8 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        return all_symbols_loaded();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load a specific symbol */", 0, 1 },
  { "    bool load_symbol(int symbol_num)", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            set_error_invalid_handle();", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        switch (symbol_num)", 0, 1 },
  { "        {", 0, 1 },
  { "        /* %%symbol%% */\n" /* multiline entry */
    "        case GDO_LOAD_%%symbol%%:\n"
    "            ptr::%%symbol%% =\n"
    "                sym_load<%%sym_type%%>\n"
    "                    (\"%%symbol%%\");\n"
    "            return (ptr::%%symbol%% != nullptr);\n"
    "", 1, 7 },
  { "        default:", 0, 1 },
  { "            break;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "# ifdef GDO_WINAPI", 0, 1 },
  { "        m_last_error = ERROR_NOT_FOUND;", 0, 1 },
  { "# endif", 0, 1 },
  { "        m_errmsg = \"unknown symbol number: \" + std::to_string(symbol_num);", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load a specific symbol by name */", 0, 1 },
  { "    bool load_symbol(const char *symbol)", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            set_error_invalid_handle();", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (!symbol || *symbol == 0) {", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "            m_last_error = ERROR_INVALID_PARAMETER;", 0, 1 },
  { "#endif", 0, 1 },
  { "            m_errmsg = \"empty symbol name\";", 0, 1 },
  { "        } else {", 0, 1 },
  { "            /* jumps to `GDO_JUMP_<..>' label if symbol was found */", 0, 1 },
  { "            GDO_CHECK_SYMBOL_NAME(symbol);", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "            m_last_error = ERROR_NOT_FOUND;", 0, 1 },
  { "#endif", 0, 1 },
  { "            m_errmsg = \"unknown symbol: \";", 0, 1 },
  { "            m_errmsg += symbol;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "", 0, 1 },
  { "        /* jump labels */", 0, 1 },
  { "\n" /* multiline entry */
    "        /* %%symbol%% */\n"
    "    GDO_JUMP_%%symbol%%:\n"
    "        ptr::%%symbol%% =\n"
    "            sym_load<%%sym_type%%>\n"
    "                (\"%%symbol%%\");\n"
    "        return (ptr::%%symbol%% != nullptr);", 1, 7 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if ALL symbols were loaded */", 0, 1 },
  { "    bool all_symbols_loaded() const", 0, 1 },
  { "    {", 0, 1 },
  { "        if (true", 0, 1 },
  { "            && ptr::%%symbol%% != nullptr", 1, 1 },
  { "        ) {", 0, 1 },
  { "            return true;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if NO symbols were loaded */", 0, 1 },
  { "    bool no_symbols_loaded() const", 0, 1 },
  { "    {", 0, 1 },
  { "        if (true", 0, 1 },
  { "            && ptr::%%symbol%% == nullptr", 1, 1 },
  { "        ) {", 0, 1 },
  { "            return true;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* check if ANY symbol was loaded */", 0, 1 },
  { "    bool any_symbol_loaded() const", 0, 1 },
  { "    {", 0, 1 },
  { "        if (false", 0, 1 },
  { "            || ptr::%%symbol%% != nullptr", 1, 1 },
  { "        ) {", 0, 1 },
  { "            return true;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return false;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* free library */", 0, 1 },
  { "    bool free()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            return true;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        bool ret = free_lib();", 0, 1 },
  { "        save_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (!ret) {", 0, 1 },
  { "            return false;", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        m_handle = nullptr;", 0, 1 },
  { "", 0, 1 },
  { "        ptr::%%symbol%% = nullptr;", 1, 1 },
  { "", 0, 1 },
  { "        return true;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* whether to free the library in the class destructor */", 0, 1 },
  { "    void free_lib_in_dtor(bool b)", 0, 1 },
  { "    {", 0, 1 },
  { "        m_free_lib_in_dtor = b;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAS_MSG_CB", 0, 1 },
  { "", 0, 1 },
  { "    /* Set a message callback function. */", 0, 1 },
  { "    static void message_callback(message_callback_t cb)", 0, 1 },
  { "    {", 0, 1 },
  { "        m_message_callback = cb;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* Get a pointer to the message callback function. */", 0, 1 },
  { "    static message_callback_t message_callback()", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_message_callback;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#endif //GDO_HAS_MSG_CB", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "    /* get path of loaded library */", 0, 1 },
  { "    std::string origin()", 0, 1 },
  { "    {", 0, 1 },
  { "        return get_origin_from_module_handle<char>();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    std::wstring origin_w()", 0, 1 },
  { "    {", 0, 1 },
  { "        return get_origin_from_module_handle<wchar_t>();", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* retrieve the last error */", 0, 1 },
  { "    std::string error()", 0, 1 },
  { "    {", 0, 1 },
  { "        std::string buf = format_last_error_message<char>();", 0, 1 },
  { "", 0, 1 },
  { "        if (buf.empty()) {", 0, 1 },
  { "            buf = \"Last saved error code: \" + std::to_string(m_last_error);", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (!m_errmsg.empty()) {", 0, 1 },
  { "            buf.insert(0, \": \");", 0, 1 },
  { "            buf.insert(0, m_errmsg);", 0, 1 },
  { "        } else if (!m_werrmsg.empty()) {", 0, 1 },
  { "            buf.insert(0, \": \");", 0, 1 },
  { "            buf.insert(0, wstr_to_str(m_werrmsg));", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return buf;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    std::wstring error_w()", 0, 1 },
  { "    {", 0, 1 },
  { "        std::wstring buf = format_last_error_message<wchar_t>();", 0, 1 },
  { "", 0, 1 },
  { "        if (buf.empty()) {", 0, 1 },
  { "            buf = L\"Last saved error code: \" + std::to_wstring(m_last_error);", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        if (!m_werrmsg.empty()) {", 0, 1 },
  { "            buf.insert(0, L\": \");", 0, 1 },
  { "            buf.insert(0, m_werrmsg);", 0, 1 },
  { "        } else if (!m_errmsg.empty()) {", 0, 1 },
  { "            buf.insert(0, L\": \");", 0, 1 },
  { "            buf.insert(0, str_to_wstr(m_errmsg));", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        return buf;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get filename passed to load */", 0, 1 },
  { "    std::string filename()", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_filename.empty() ? wstr_to_str(m_wfilename) : m_filename;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    std::wstring filename_w()", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_wfilename.empty() ? str_to_wstr(m_filename) : m_wfilename;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#else", 0, 1 },
  { "/*********************************** dlfcn ***********************************/", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get path of loaded library */", 0, 1 },
  { "    std::string origin()", 0, 1 },
  { "    {", 0, 1 },
  { "        clear_error();", 0, 1 },
  { "", 0, 1 },
  { "        if (!lib_loaded()) {", 0, 1 },
  { "            set_error_invalid_handle();", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAVE_DLINFO", 0, 1 },
  { "        struct link_map *lm = nullptr;", 0, 1 },
  { "", 0, 1 },
  { "        int ret = ::dlinfo(m_handle, RTLD_DI_LINKMAP, reinterpret_cast<void *>(&lm));", 0, 1 },
  { "        save_error();", 0, 1 },
  { "", 0, 1 },
  { "        return (ret != -1 && lm->l_name) ? lm->l_name : \"\";", 0, 1 },
  { "#else", 0, 1 },
  { "        /* use dladdr() to get the library path from a symbol pointer */", 0, 1 },
  { "        std::string fname;", 0, 1 },
  { "", 0, 1 },
  { "        if (no_symbols_loaded()) {", 0, 1 },
  { "            m_errmsg = \"no symbols were loaded\";", 0, 1 },
  { "            return {};", 0, 1 },
  { "        }", 0, 1 },
  { "", 0, 1 },
  { "        auto get_fname = [&fname] (const void *ptr)", 0, 1 },
  { "        {", 0, 1 },
  { "            Dl_info info;", 0, 1 },
  { "", 0, 1 },
  { "            if (ptr && ::dladdr(ptr, &info) != 0 && info.dli_fname) {", 0, 1 },
  { "                fname = info.dli_fname;", 0, 1 },
  { "            }", 0, 1 },
  { "        };", 0, 1 },
  { "", 0, 1 },
  { "        get_fname(reinterpret_cast<void *>(ptr::%%symbol%%));\n" /* multiline entry */
    "        if (!fname.empty()) return fname;", 1, 2 },
  { "", 0, 1 },
  { "        m_errmsg = \"dladdr() failed to get library path\";", 0, 1 },
  { "", 0, 1 },
  { "        return {};", 0, 1 },
  { "#endif // !GDO_HAVE_DLINFO", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* retrieve the last error */", 0, 1 },
  { "    std::string error() const", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_errmsg;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get filename passed to load */", 0, 1 },
  { "    std::string filename() const", 0, 1 },
  { "    {", 0, 1 },
  { "        return m_filename;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#endif // !GDO_WINAPI", 0, 1 },
  { "", 0, 1 },
  { "};", 0, 1 },
  { "/******************************* end of class ********************************/", 0, 1 },
  { "", 0, 1 },
  { "} /* end namespace */", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* prefixed aliases, useful if GDO_DISABLE_ALIASING was defined */", 0, 1 },
  { "#define GDO_ALIAS_%%func_symbol_pad%% gdo::ptr::%%func_symbol%%", 1, 1 },
  { "#define GDO_ALIAS_%%obj_symbol_pad%% *gdo::ptr::%%obj_symbol%%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* disable aliasing if we saved into separate files and the", 0, 1 },
  { " * header file was included from the body file */", 0, 1 },
  { "#if defined(GDO_SEPARATE) && !defined(GDO_INCLUDED_IN_BODY)", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw function pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "#define %%func_symbol_pad%% GDO_ALIAS_%%func_symbol_pad%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw object pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING)", 0, 1 },
  { "#define %%obj_symbol_pad%% GDO_ALIAS_%%obj_symbol_pad%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#endif //GDO_SEPARATE && !GDO_INCLUDED_IN_BODY", 0, 1 },
  { "", 0, 1 },
  { NULL, 0, 0 }
};

/* cxx.cpp */
static constexpr template_t cxx_body[] = {
  { "#line 1 \"<built-in>/cxx.cpp\"", 0, 1 },
  { "#ifdef GDO_HAS_MSG_CB", 0, 1 },
  { "gdo::dl::message_callback_t gdo::dl::m_message_callback = nullptr;", 0, 1 },
  { "#endif", 0, 1 },
  { "gdo::dl::handle_t gdo::dl::m_handle = nullptr;", 0, 1 },
  { "", 0, 1 },
  { "%%type%% (*gdo::ptr::%%func_symbol%%)(%%args%%) = nullptr;", 1, 1 },
  { "%%obj_type%% *gdo::ptr::%%obj_symbol%% = nullptr;", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Create versioned library names for DLLs, dylibs and DSOs.", 0, 1 },
  { " * make_libname(\"z\",1) for example will return \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\" */", 0, 1 },
  { "std::string gdo::make_libname(const std::string &name, const size_t api)", 0, 1 },
  { "{", 0, 1 },
  { "#ifdef _WIN32", 0, 1 },
  { "    return \"lib\" + name + '-' + std::to_string(api) + \".dll\";", 0, 1 },
  { "#elif defined(__APPLE__)", 0, 1 },
  { "    return \"lib\" + name + '.' + std::to_string(api) + \".dylib\";", 0, 1 },
  { "#elif defined(_AIX)", 0, 1 },
  { "    UNUSED_VAL_(api);", 0, 1 },
  { "    return \"lib\" + name + \".a\";", 0, 1 },
  { "#elif defined(__ANDROID__)", 0, 1 },
  { "    UNUSED_VAL_(api);", 0, 1 },
  { "    return \"lib\" + name + \".so\";", 0, 1 },
  { "#else", 0, 1 },
  { "    return \"lib\" + name + \".so.\" + std::to_string(api);", 0, 1 },
  { "#endif", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_WINAPI", 0, 1 },
  { "std::wstring gdo::make_libname(const std::wstring &name, const size_t api)", 0, 1 },
  { "{", 0, 1 },
  { "    return L\"lib\" + name + L'-' + std::to_wstring(api) + L\".dll\";", 0, 1 },
  { "}", 0, 1 },
  { "#endif //GDO_WINAPI", 0, 1 },
  { "%PARAM_SKIP_REMOVE_BEGIN%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_HAS_MSG_CB", 0, 1 },
  { "", 0, 1 },
  { "#include <iostream>", 0, 1 },
  { "#include <cstdlib>", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* helpers used by function wrappers */", 0, 1 },
  { "namespace gdo", 0, 1 },
  { "{", 0, 1 },
  { "    namespace helper", 0, 1 },
  { "    {", 0, 1 },
  { "        static void error_exit(const char *msg)", 0, 1 },
  { "        {", 0, 1 },
  { "            auto cb = gdo::dl::message_callback();", 0, 1 },
  { "", 0, 1 },
  { "            if (cb) {", 0, 1 },
  { "                cb(msg);", 0, 1 },
  { "            } else {", 0, 1 },
  { "                std::cerr << msg << std::endl;", 0, 1 },
  { "            }", 0, 1 },
  { "", 0, 1 },
  { "            std::exit(1);", 0, 1 },
  { "        }", 0, 1 },
  { "    }", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "#endif //GDO_HAS_MSG_CB", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#ifndef GDO_HOOK_%%func_symbol%%\n" /* multiline entry */
    "#define GDO_HOOK_%%func_symbol%%(...) /**/\n"
    "#endif", 1, 3 },
  { "", 0, 1 },
  { "#if defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* function wrappers (functions with `...' arguments are omitted) */", 0, 1 },
  { "\n" /* multiline entry */
    "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
    "    if (!gdo::ptr::%%func_symbol%%) {\n"
    "        gdo::helper::error_exit(\"error: symbol `%%func_symbol%%' was not loaded\");\n"
    "    }\n"
    "    GDO_HOOK_%%func_symbol%%(%%notype_args%%);\n"
    "    %%return%% gdo::ptr::%%func_symbol%%(%%notype_args%%);\n"
    "}", 1, 8 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#elif defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "namespace gdo", 0, 1 },
  { "{", 0, 1 },
  { "    namespace /* anonymous */ {", 0, 1 },
  { "        auto _gdo_al = gdo::dl(GDO_DEFAULT_LIBA);", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "    namespace helper", 0, 1 },
  { "    {", 0, 1 },
  { "        /* used internally by wrapper functions, symbol is never NULL */", 0, 1 },
  { "        static void quick_load(int symbol_num, const char *symbol)", 0, 1 },
  { "        {", 0, 1 },
  { "            if (!_gdo_al.load()) {", 0, 1 },
  { "                std::string msg = \"error loading library `\" GDO_DEFAULT_LIBA \"':\\n\" + _gdo_al.error();", 0, 1 },
  { "                error_exit(msg.c_str());", 0, 1 },
  { "            }", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_DELAYLOAD", 0, 1 },
  { "            bool loaded = _gdo_al.load_symbol(symbol_num);", 0, 1 },
  { "#else", 0, 1 },
  { "            bool loaded = _gdo_al.load_all_symbols();", 0, 1 },
  { "            UNUSED_VAL_(symbol_num);", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "            if (!loaded) {", 0, 1 },
  { "                std::string msg = \"error in auto-loading wrapper function `gdo::autoload::\";", 0, 1 },
  { "                msg += symbol + (\"': \" + _gdo_al.error());", 0, 1 },
  { "                error_exit(msg.c_str());", 0, 1 },
  { "            }", 0, 1 },
  { "        }", 0, 1 },
  { "    }", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* autoload function wrappers (functions with `...' arguments are omitted) */", 0, 1 },
  { "\n" /* multiline entry */
    "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
    "    gdo::helper::quick_load(GDO_LOAD_%%func_symbol%%, \"%%func_symbol%%\");\n"
    "    GDO_HOOK_%%func_symbol%%(%%notype_args%%);\n"
    "    %%return%% gdo::ptr::%%func_symbol%%(%%notype_args%%);\n"
    "}", 1, 6 },
  { "", 0, 1 },
  { "#endif //GDO_ENABLE_AUTOLOAD", 0, 1 },
  { "%PARAM_SKIP_END%", 1, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_SEPARATE) /* single header file */", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw function pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)", 0, 1 },
  { "#define %%func_symbol_pad%% GDO_ALIAS_%%func_symbol_pad%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw object pointers */", 0, 1 },
  { "#if !defined(GDO_DISABLE_ALIASING)", 0, 1 },
  { "#define %%obj_symbol_pad%% GDO_ALIAS_%%obj_symbol_pad%%", 1, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#endif //GDO_SEPARATE && !GDO_INCLUDED_IN_BODY", 0, 1 },
  { NULL, 0, 0 }
};

/* minimal.h */
static constexpr template_t min_c_header[] = {
  { "#line 1 \"<built-in>/minimal.h\"", 0, 1 },
  { "#ifdef GDO_USE_SDL", 0, 1 },
  { "/* SDL API */", 0, 1 },
  { "# include <SDL_loadso.h>", 0, 1 },
  { "# define GDO_LOAD_LIB(filename)       SDL_LoadObject(filename)", 0, 1 },
  { "# define GDO_FREE_LIB(handle)         SDL_UnloadObject(handle)", 0, 1 },
  { "# define GDO_GET_SYM(handle, symbol)  SDL_LoadFunction(handle, symbol)", 0, 1 },
  { "#elif defined(_WIN32) && !defined(GDO_USE_DLOPEN)", 0, 1 },
  { "/* WinAPI */", 0, 1 },
  { "# include <windows.h>", 0, 1 },
  { "# define GDO_LOAD_LIB(filename)       (void *)LoadLibraryA(filename)", 0, 1 },
  { "# define GDO_FREE_LIB(handle)         FreeLibrary((HMODULE)handle)", 0, 1 },
  { "# define GDO_GET_SYM(handle, symbol)  (void *)GetProcAddress((HMODULE)handle, symbol)", 0, 1 },
  { "#else", 0, 1 },
  { "/* POSIX */", 0, 1 },
  { "# include <dlfcn.h>", 0, 1 },
  { "# define GDO_LOAD_LIB(filename)       dlopen(filename, RTLD_LAZY)", 0, 1 },
  { "# define GDO_FREE_LIB(handle)         dlclose(handle)", 0, 1 },
  { "# define GDO_GET_SYM(handle, symbol)  dlsym(handle, symbol)", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_STATIC", 0, 1 },
  { "# define GDO_LINKAGE  static", 0, 1 },
  { "#else", 0, 1 },
  { "# define GDO_LINKAGE  /**/", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* Our library and symbols handle */", 0, 1 },
  { "typedef struct gdo_handle", 0, 1 },
  { "{", 0, 1 },
  { "    void *handle;", 0, 1 },
  { "", 0, 1 },
  { "    %%type%% (*%%func_symbol%%)(%%args%%);", 1, 1 },
  { "    %%obj_type%% *%%obj_symbol%%;", 1, 1 },
  { "", 0, 1 },
  { "} gdo_handle_t;", 0, 1 },
  { "", 0, 1 },
  { "GDO_LINKAGE gdo_handle_t gdo_hndl;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/* returns NULL on success and an error message if loading failed */", 0, 1 },
  { "GDO_LINKAGE const char *gdo_load_library_and_symbols(const char *filename)", 0, 1 },
  { "{", 0, 1 },
  { "    gdo_hndl.handle = GDO_LOAD_LIB(filename);", 0, 1 },
  { "", 0, 1 },
  { "    if (!gdo_hndl.handle) {", 0, 1 },
  { "        return \"failed to load library\";", 0, 1 },
  { "    }", 0, 1 },
  { "\n" /* multiline entry */
    "    /* %%symbol%% */\n"
    "    gdo_hndl.%%symbol%% =\n"
    "        (%%sym_type%%)\n"
    "            GDO_GET_SYM(gdo_hndl.handle, \"%%symbol%%\");\n"
    "    if (!gdo_hndl.%%symbol%%) {\n"
    "        GDO_FREE_LIB(gdo_hndl.handle);\n"
    "        return \"failed to load symbol: %%symbol%%\";\n"
    "    }", 1, 9 },
  { "", 0, 1 },
  { "    return NULL;", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "/* free library handle, no error checks */", 0, 1 },
  { "GDO_LINKAGE void gdo_free_library(void)", 0, 1 },
  { "{", 0, 1 },
  { "    GDO_FREE_LIB(gdo_hndl.handle);", 0, 1 },
  { "}", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_NOALIAS)", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw symbol pointers */", 0, 1 },
  { "#define %%func_symbol%%  gdo_hndl.%%func_symbol%%", 1, 1 },
  { "#define %%obj_symbol%%  *gdo_hndl.%%obj_symbol%%", 1, 1 },
  { "", 0, 1 },
  { "#endif // !GDO_NOALIAS", 0, 1 },
  { NULL, 0, 0 }
};

/* minimal_cxxeh.hpp */
static constexpr template_t min_cxx_header[] = {
  { "#line 1 \"<built-in>/minimal_cxxeh.hpp\"", 0, 1 },
  { "#include <stdexcept>", 0, 1 },
  { "#include <string>", 0, 1 },
  { "", 0, 1 },
  { "#ifdef GDO_USE_SDL", 0, 1 },
  { "# include <SDL_loadso.h>", 0, 1 },
  { "#elif defined(_WIN32) && !defined(GDO_USE_DLOPEN)", 0, 1 },
  { "# define GDO_WINAPI", 0, 1 },
  { "# include <windows.h>", 0, 1 },
  { "#else", 0, 1 },
  { "# include <dlfcn.h>", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "/***", 0, 1 },
  { "", 0, 1 },
  { "A small C++ library loader that throws exceptions on error.", 0, 1 },
  { "", 0, 1 },
  { "Usage:", 0, 1 },
  { "", 0, 1 },
  { "    try {", 0, 1 },
  { "        gdo::load_library_and_symbols( LIBNAME(helloworld,0) );", 0, 1 },
  { "    }", 0, 1 },
  { "    catch (const gdo::LibraryError &e) {", 0, 1 },
  { "        std::cerr << \"error: failed to load library: \" << e.what() << std::endl;", 0, 1 },
  { "        return 1;", 0, 1 },
  { "    }", 0, 1 },
  { "    catch (const gdo::SymbolError &e) {", 0, 1 },
  { "        std::cerr << \"error: failed to load symbol: \" << e.what() << std::endl;", 0, 1 },
  { "        return 1;", 0, 1 },
  { "    }", 0, 1 },
  { "    catch (...) {", 0, 1 },
  { "        std::cerr << \"an unknown error has occurred\" << std::endl;", 0, 1 },
  { "        return 1;", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "***/", 0, 1 },
  { "", 0, 1 },
  { "namespace gdo", 0, 1 },
  { "{", 0, 1 },
  { "    /* symbol pointers */", 0, 1 },
  { "    namespace ptr", 0, 1 },
  { "    {", 0, 1 },
  { "        %%type%% (*%%func_symbol%%)(%%args%%) = nullptr;", 1, 1 },
  { "        %%obj_type%% *%%obj_symbol%% = nullptr;", 1, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "#if defined(GDO_USE_SDL) || defined(GDO_WINAPI)", 0, 1 },
  { "    const int default_flags = 0;", 0, 1 },
  { "#else", 0, 1 },
  { "    const int default_flags = RTLD_LAZY;", 0, 1 },
  { "#endif", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* library handle */", 0, 1 },
  { "    void *handle = nullptr;", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* load library */", 0, 1 },
  { "    void *load_lib(const char *filename, int flags=default_flags)", 0, 1 },
  { "    {", 0, 1 },
  { "#ifdef GDO_USE_SDL", 0, 1 },
  { "        static_cast<void>(flags);", 0, 1 },
  { "        return SDL_LoadObject(filename);", 0, 1 },
  { "#elif defined(GDO_WINAPI)", 0, 1 },
  { "        return reinterpret_cast<void *>(::LoadLibraryExA(filename, nullptr, flags));", 0, 1 },
  { "#else", 0, 1 },
  { "        return ::dlopen(filename, flags);", 0, 1 },
  { "#endif", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* free library (no error checks) */", 0, 1 },
  { "    void free_lib(void *handle)", 0, 1 },
  { "    {", 0, 1 },
  { "#ifdef GDO_USE_SDL", 0, 1 },
  { "        SDL_UnloadObject(handle);", 0, 1 },
  { "#elif defined(GDO_WINAPI)", 0, 1 },
  { "        ::FreeLibrary(reinterpret_cast<HMODULE>(handle));", 0, 1 },
  { "#else", 0, 1 },
  { "        ::dlclose(handle);", 0, 1 },
  { "#endif", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* get symbol */", 0, 1 },
  { "    void *get_symbol(void *handle, const char *symbol)", 0, 1 },
  { "    {", 0, 1 },
  { "#ifdef GDO_USE_SDL", 0, 1 },
  { "        return SDL_LoadFunction(handle, symbol);", 0, 1 },
  { "#elif defined(GDO_WINAPI)", 0, 1 },
  { "        return reinterpret_cast<void *>(::GetProcAddress(", 0, 1 },
  { "            reinterpret_cast<HMODULE>(handle), symbol));", 0, 1 },
  { "#else", 0, 1 },
  { "        return ::dlsym(handle, symbol);", 0, 1 },
  { "#endif", 0, 1 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* base error class */", 0, 1 },
  { "    class Error : public std::runtime_error", 0, 1 },
  { "    {", 0, 1 },
  { "        public:", 0, 1 },
  { "            Error(const std::string &message) : std::runtime_error(message) {}", 0, 1 },
  { "            virtual ~Error() {}", 0, 1 },
  { "    };", 0, 1 },
  { "", 0, 1 },
  { "    /* library loading error */", 0, 1 },
  { "    class LibraryError : public Error", 0, 1 },
  { "    {", 0, 1 },
  { "        public:", 0, 1 },
  { "            LibraryError(const std::string &message) : Error(message) {}", 0, 1 },
  { "            virtual ~LibraryError() {}", 0, 1 },
  { "    };", 0, 1 },
  { "", 0, 1 },
  { "    /* symbol loading error */", 0, 1 },
  { "    class SymbolError : public Error", 0, 1 },
  { "    {", 0, 1 },
  { "        public:", 0, 1 },
  { "            SymbolError(const std::string &message) : Error(message) {}", 0, 1 },
  { "            virtual ~SymbolError() {}", 0, 1 },
  { "    };", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "    /* throw an exception on error */", 0, 1 },
  { "    void load_library_and_symbols(const char *filename) noexcept(false)", 0, 1 },
  { "    {", 0, 1 },
  { "        handle = load_lib(filename);", 0, 1 },
  { "", 0, 1 },
  { "        if (!handle) {", 0, 1 },
  { "            if (filename == NULL) {", 0, 1 },
  { "                filename = \"<NULL>\";", 0, 1 },
  { "            } else if (*filename == 0) {", 0, 1 },
  { "                filename = \"<EMPTY>\";", 0, 1 },
  { "            }", 0, 1 },
  { "", 0, 1 },
  { "            throw LibraryError(filename);", 0, 1 },
  { "        }", 0, 1 },
  { "\n" /* multiline entry */
    "        /* %%symbol%% */\n"
    "        ptr::%%symbol%% =\n"
    "            reinterpret_cast<%%sym_type%%>(\n"
    "                get_symbol(handle, \"%%symbol%%\"));\n"
    "        if (!ptr::%%symbol%%) {\n"
    "            free_lib(handle);\n"
    "            throw SymbolError(\"%%symbol%%\");\n"
    "        }", 1, 9 },
  { "    }", 0, 1 },
  { "", 0, 1 },
  { "}; /* end namespace */", 0, 1 },
  { "", 0, 1 },
  { "", 0, 1 },
  { "#if !defined(GDO_NOALIAS)", 0, 1 },
  { "", 0, 1 },
  { "/* aliases to raw symbol pointers */", 0, 1 },
  { "#define %%func_symbol%%  gdo::ptr::%%func_symbol%%", 1, 1 },
  { "#define %%obj_symbol%%  *gdo::ptr::%%obj_symbol%%", 1, 1 },
  { "", 0, 1 },
  { "#endif // !GDO_NOALIAS", 0, 1 },
  { NULL, 0, 0 }
};

