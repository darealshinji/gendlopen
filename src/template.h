/* this file was automatically generated; do not edit! */

#ifndef _TEMPLATE_H_
#define _TEMPLATE_H_

/* filename_macros.h */
static const char *filename_macros[] = {
  "",
  "/*****************************************************************************/",
  "/*                              filename macros                              */",
  "/*****************************************************************************/",
  "",
  "/* default library filename extension */",
  "#ifdef LIBEXT",
  "# undef LIBEXT",
  "#endif",
  "#ifdef LIBEXTA",
  "# undef LIBEXTA",
  "#endif",
  "#ifdef LIBEXTW",
  "# undef LIBEXTW",
  "#endif",
  "#ifdef _WIN32",
  "# define LIBEXTA    \".dll\"",
  "# define LIBEXTW   L\".dll\"",
  "#elif defined(__APPLE__) && defined(__MACH__)",
  "# define LIBEXTA    \".dylib\"",
  "# define LIBEXTW   L\".dylib\"",
  "#elif defined(_AIX)",
  "# define LIBEXTA    \".a\"",
  "# define LIBEXTW   L\".a\"",
  "#else /* ELF */",
  "# define LIBEXTA    \".so\"",
  "# define LIBEXTW   L\".so\"",
  "#endif",
  "",
  "/**",
  " * library name with API number",
  " *",
  " * Examples using LIBNAME(foo, 1.2) macro:",
  " *",
  " * Windows: libfoo-1.2.dll",
  " * De-facto standard when libraries are ported to Windows.",
  " *",
  " * macOS: libfoo.1.2.dylib",
  " *",
  " * AIX: libfoo.a",
  " * AIX uses archive files without API number.",
  " *",
  " * Android: libfoo.so",
  " * ELF format but without API number.",
  " *",
  " * ELF: libfoo.so.1.2",
  " */",
  "#ifdef LIBNAME",
  "# undef LIBNAME",
  "#endif",
  "#ifdef LIBNAMEA",
  "# undef LIBNAMEA",
  "#endif",
  "#ifdef LIBNAMEW",
  "# undef LIBNAMEW",
  "#endif",
  "#ifdef _WIN32",
  "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \"-\" #API \".dll\"",
  "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \"-\" #API \".dll\"",
  "#elif defined(__APPLE__) && defined(__MACH__)",
  "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".\" #API \".dylib\"",
  "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".\" #API \".dylib\"",
  "#elif defined(_AIX)",
  "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".a\"",
  "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".a\"",
  "#elif defined(__ANDROID__)",
  "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".so\"",
  "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".so\"",
  "#else /* default ELF filename */",
  "# define LIBNAMEA(NAME, API)    \"lib\" #NAME \".so.\" #API",
  "# define LIBNAMEW(NAME, API)   L\"lib\" #NAME \".so.\" #API",
  "#endif",
  "",
  "/* Unicode/ANSI default macros */",
  "#if defined(_WIN32) && defined(_UNICODE)",
  "# define LIBEXT              LIBEXTW",
  "# define LIBNAME(NAME, API)  LIBNAMEW(NAME, API)",
  "#else",
  "# define LIBEXT              LIBEXTA",
  "# define LIBNAME(NAME, API)  LIBNAMEA(NAME, API)",
  "#endif",
  NULL
};

/* license.h */
static const char *license[] = {
  "/**",
  " Licensed under the MIT License <http://opensource.org/licenses/MIT>.",
  " SPDX-License-Identifier: MIT",
  " Copyright (c) 2023-2024 Carsten Janssen",
  "",
  " Permission is hereby  granted, free of charge, to any  person obtaining a copy",
  " of this software and associated  documentation files (the \"Software\"), to deal",
  " in the Software  without restriction, including without  limitation the rights",
  " to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell",
  " copies  of  the Software,  and  to  permit persons  to  whom  the Software  is",
  " furnished to do so, subject to the following conditions:",
  "",
  " The above copyright notice and this permission notice shall be included in all",
  " copies or substantial portions of the Software.",
  "",
  " THE SOFTWARE  IS PROVIDED \"AS  IS\", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR",
  " IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,",
  " FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE",
  " AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER",
  " LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
  " OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE",
  " SOFTWARE.",
  "**/",
  NULL
};

/* common.h */
static const char *common_header[] = {
  "",
  "/*****************************************************************************/",
  "/*                         common macros and headers                         */",
  "/*****************************************************************************/",
  "",
  "/* whether to use WinAPI or dlfcn */",
  "#if defined(_WIN32) && !defined(GDO_USE_DLOPEN)",
  "# define GDO_WINAPI",
  "#endif",
  "",
  "/* default headers to include */",
  "#ifdef GDO_WINAPI",
  "# include <windows.h>",
  "#else",
  "# include <sys/types.h>",
  "# include <link.h>",
  "# include <dlfcn.h>",
  "#endif",
  "#ifndef __cplusplus",
  "# include <stdbool.h>",
  "#endif",
  "",
  "/* default library name */",
  "#ifndef GDO_DEFAULT_LIB",
  "# if defined(GDO_DEFAULT_LIBW) && defined(GDO_WINAPI) && defined(_UNICODE)",
  "#  define GDO_DEFAULT_LIB  GDO_DEFAULT_LIBW",
  "# elif defined(GDO_DEFAULT_LIBA)",
  "#  define GDO_DEFAULT_LIB  GDO_DEFAULT_LIBA",
  "# endif",
  "#endif",
  "",
  "/* whether to use dlinfo(3);",
  " * n/a on Windows (both APIs), OpenBSD, Haiku */",
  "#if !defined(_WIN32) && !defined(__OpenBSD__) && !defined(__HAIKU__) && \\",
  "    !defined(GDO_DISABLE_DLINFO)",
  "# define GDO_HAVE_DLINFO",
  "#endif",
  "",
  "/* whether to use dlmopen(3);",
  " * only available on Glibc and Solaris/IllumOS */",
  "#if (defined(__GLIBC__) || defined(__sun)) && !defined(GDO_DISABLE_DLMOPEN)",
  "# define GDO_HAVE_DLMOPEN",
  "#endif",
  "",
  "/* dlopen(3) flags for compatibility with LoadLibrary() */",
  "/* taken from different implementations of dlfcn.h */",
  "#ifndef RTLD_LAZY",
  "#define RTLD_LAZY 0",
  "#endif",
  "#ifndef RTLD_NOW",
  "#define RTLD_NOW 0",
  "#endif",
  "#ifndef RTLD_MODEMASK",
  "#define RTLD_MODEMASK 0  /* FreeBSD, DragonFlyBSD */",
  "#endif",
  "#ifndef RTLD_BINDING_MASK",
  "#define RTLD_BINDING_MASK 0  /* glibc */",
  "#endif",
  "#ifndef RTLD_GLOBAL",
  "#define RTLD_GLOBAL 0",
  "#endif",
  "#ifndef RTLD_LOCAL",
  "#define RTLD_LOCAL 0",
  "#endif",
  "#ifndef RTLD_NODELETE",
  "#define RTLD_NODELETE 0",
  "#endif",
  "#ifndef RTLD_NOLOAD",
  "#define RTLD_NOLOAD 0",
  "#endif",
  "#ifndef RTLD_DEEPBIND",
  "#define RTLD_DEEPBIND 0  /* glibc, FreeBSD */",
  "#endif",
  "#ifndef RTLD_TRACE",
  "#define RTLD_TRACE 0  /* FreeBSD, OpenBSD, DragonFlyBSD */",
  "#endif",
  "#ifndef RTLD_GROUP",
  "#define RTLD_GROUP 0  /* Solaris */",
  "#endif",
  "#ifndef RTLD_PARENT",
  "#define RTLD_PARENT 0  /* Solaris */",
  "#endif",
  "#ifndef RTLD_WORLD",
  "#define RTLD_WORLD 0  /* Solaris */",
  "#endif",
  "#ifndef RTLD_FIRST",
  "#define RTLD_FIRST 0  /* macOS, Solaris */",
  "#endif",
  "#ifndef RTLD_MEMBER",
  "#define RTLD_MEMBER 0  /* AIX */",
  "#endif",
  "#ifndef RTLD_NOAUTODEFER",
  "#define RTLD_NOAUTODEFER 0  /* AIX */",
  "#endif",
  "#ifndef DL_LAZY",
  "#define DL_LAZY RTLD_LAZY  /* NetBSD, OpenBSD */",
  "#endif",
  "",
  "/* LoadLibrary() flags for compatibility with dlopen() */",
  "/* https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw */",
  "#ifndef DONT_RESOLVE_DLL_REFERENCES",
  "#define DONT_RESOLVE_DLL_REFERENCES 0",
  "#endif",
  "#ifndef LOAD_IGNORE_CODE_AUTHZ_LEVEL",
  "#define LOAD_IGNORE_CODE_AUTHZ_LEVEL 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_AS_DATAFILE",
  "#define LOAD_LIBRARY_AS_DATAFILE 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE",
  "#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_AS_IMAGE_RESOURCE",
  "#define LOAD_LIBRARY_AS_IMAGE_RESOURCE 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SEARCH_APPLICATION_DIR",
  "#define LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SEARCH_DEFAULT_DIRS",
  "#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR",
  "#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SEARCH_SYSTEM32",
  "#define LOAD_LIBRARY_SEARCH_SYSTEM32 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SEARCH_USER_DIRS",
  "#define LOAD_LIBRARY_SEARCH_USER_DIRS 0",
  "#endif",
  "#ifndef LOAD_WITH_ALTERED_SEARCH_PATH",
  "#define LOAD_WITH_ALTERED_SEARCH_PATH 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_REQUIRE_SIGNED_TARGET",
  "#define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET 0",
  "#endif",
  "#ifndef LOAD_LIBRARY_SAFE_CURRENT_DIRS",
  "#define LOAD_LIBRARY_SAFE_CURRENT_DIRS 0",
  "#endif",
  "",
  "/* symbol visibility */",
  "#ifndef GDO_VISIBILITY",
  "# define GDO_VISIBILITY",
  "#endif",
  "",
  "/* default flags */",
  "#ifndef GDO_DEFAULT_FLAGS",
  "# ifdef GDO_WINAPI",
  "#  define GDO_DEFAULT_FLAGS 0",
  "# else",
  "#  define GDO_DEFAULT_FLAGS (RTLD_LAZY | RTLD_MEMBER)",
  "# endif",
  "#endif",
  "",
  "%PARAM_SKIP_REMOVE_BEGIN%",
  "#if defined(GDO_ENABLE_AUTOLOAD) && !defined(GDO_DEFAULT_LIB)",
  "# error You need to define GDO_DEFAULT_LIB if you want to make use of GDO_ENABLE_AUTOLOAD",
  "#endif",
  "#if defined(GDO_DELAYLOAD) && !defined(GDO_ENABLE_AUTOLOAD)",
  "# error You need to define GDO_ENABLE_AUTOLOAD if you want to make use of GDO_DELAYLOAD",
  "#endif",
  "#if defined(GDO_WRAP_FUNCTIONS) || defined(GDO_ENABLE_AUTOLOAD)",
  "# define GDO_HAS_MSG_CB",
  "#endif",
  "%PARAM_SKIP_USE_BEGIN%",
  "#if defined(GDO_WRAP_FUNCTIONS)",
  "# error \"GDO_WRAP_FUNCTIONS\" defined but wrapped functions were disabled with \"-param=skip\"",
  "#endif",
  "#if defined(GDO_ENABLE_AUTOLOAD)",
  "# error \"GDO_ENABLE_AUTOLOAD\" defined but wrapped functions were disabled with \"-param=skip\"",
  "#endif",
  "%PARAM_SKIP_END%",
  NULL
};

/* c.h */
static const char *c_header[] = {
  "",
  "/***",
  "",
  "******************",
  "*   gdo_char_t   *",
  "******************",
  "",
  "If compiling for win32 and `_UNICODE` is defined and `GDO_USE_DLOPEN` is NOT defined",
  "`gdo_char_t` will become `wchar_t`.",
  "",
  "Otherwise `gdo_char_t` will become `char`.",
  "",
  "",
  "**************************",
  "*   Functions provided   *",
  "**************************",
  "",
  "bool               gdo_load_lib ();",
  "bool               gdo_load_lib_and_symbols ();",
  "bool               gdo_load_lib_name (const gdo_char_t *filename);",
  "bool               gdo_load_lib_name_and_symbols (const gdo_char_t *filename);",
  "bool               gdo_load_lib_args (const gdo_char_t *filename, int flags, bool new_namespace);",
  "",
  "bool               gdo_lib_is_loaded ();",
  "bool               gdo_free_lib ();",
  "",
  "bool               gdo_all_symbols_loaded ();",
  "bool               gdo_no_symbols_loaded ();",
  "bool               gdo_any_symbol_loaded ();",
  "bool               gdo_load_all_symbols (bool ignore_errors);",
  "bool               gdo_load_symbol (const char *symbol);",
  "",
  "bool               gdo_all_symbols_loaded ();",
  "bool               gdo_no_symbols_loaded ();",
  "bool               gdo_any_symbol_loaded ();",
  "",
  "const gdo_char_t * gdo_last_error ();",
  "gdo_char_t *       gdo_lib_origin ();",
  "",
  "",
  "",
  "bool gdo_load_lib ();",
  "",
  "    Load the library specified by the macro GDO_DEFAULT_LIB using default flags.",
  "    This function is not available if GDO_DEFAULT_LIB was not defined.",
  "",
  "",
  "bool gdo_load_lib_and_symbols ();",
  "",
  "    Calls gdo_load_lib() and gdo_load_symbols().",
  "",
  "",
  "bool gdo_load_lib_name (const gdo_char_t *filename);",
  "",
  "    Load the library specified by `filename' using default flags.",
  "",
  "",
  "bool gdo_load_lib_name_and_symbols (const gdo_char_t *filename);",
  "",
  "    Calls gdo_load_lib_name() and gdo_load_symbols().",
  "",
  "",
  "bool gdo_load_lib_args (const gdo_char_t *filename, int flags, bool new_namespace);",
  "",
  "    Load the library; `filename' and `flags' are passed to the underlying library",
  "    loading functions.",
  "",
  "    If `new_namespace' is true the library will be loaded into a new namespace.",
  "    This is done using dlmopen() with the LM_ID_NEWLM argument.",
  "    This argument is only used on Glibc and if _GNU_SOURCE was defined.",
  "",
  "",
  "bool gdo_lib_is_loaded ();",
  "",
  "    Returns true if the library was successfully loaded.",
  "",
  "",
  "bool gdo_free_lib ();",
  "",
  "    Free/release library handle.",
  "",
  "",
  "bool gdo_load_symbols (bool ignore_errors);",
  "",
  "    Load the symbols. This function can safely be called multiple times.",
  "    If ignore_errors is set true the function won't stop on the first",
  "    symbol that can't be loaded but instead tries to load them all.",
  "    If one or more symbols weren't loaded the function returns false.",
  "",
  "",
  "bool gdo_load_symbol (const char *symbol);",
  "",
  "    Load a specific symbol.",
  "",
  "",
  "bool gdo_all_symbols_loaded ();",
  "",
  "    Returns true if ALL symbols were successfully loaded.",
  "",
  "",
  "bool gdo_no_symbols_loaded ();",
  "",
  "    Returns true if NO symbols were loaded at all.",
  "",
  "",
  "bool gdo_any_symbol_loaded ();",
  "",
  "    Returns true if 1 or more symbols were successfully loaded.",
  "",
  "",
  "const gdo_char_t *gdo_last_error ();",
  "",
  "    Returns a pointer to the error message buffer with the last saved error string.",
  "    This buffer can be empty and is in fact cleared when no error occured in a function.",
  "    This function doesn't return a null pointer.",
  "",
  "",
  "gdo_char_t *gdo_lib_origin ();",
  "",
  "    Return the full library path. The returned string must be deallocated with free().",
  "    On error or if no library was loaded NULL is returned.",
  "",
  "",
  "",
  "****************************************************",
  "* The following options may be set through macros: *",
  "****************************************************",
  "",
  "GDO_USE_DLOPEN",
  "    If defined use `dlopen()' API on win32 targets.",
  "    On other targets `dlopen()' is always used.",
  "",
  "GDO_STATIC",
  "    If defined static linkage (the `static' keyword) is used for all",
  "    functions.",
  "",
  "GDO_DEFAULT_FLAGS",
  "    Override the default flags to use when loading a library.",
  "",
  "GDO_DEFAULT_LIB",
  "    Set a default library name through this macro (including double quote",
  "    marks). This macro must be defined if you want to set GDO_ENABLE_AUTOLOAD",
  "    or if you want to use the `gdo_load_lib()' function.",
  "",
  "GDO_WRAP_FUNCTIONS",
  "    Use actual wrapped functions instead of a name alias. This is useful if you",
  "    want to create a library to later link an application against.",
  "",
  "GDO_ENABLE_AUTOLOAD",
  "    Define this macro if you want to use auto-loading wrapper functions.",
  "    This means you don't need to explicitly call library load functions.",
  "    The first wrapper function called will load all symbols at once.",
  "    It requires GDO_DEFAULT_LIB to be defined.",
  "    If an error occures during loading these functions print an error message",
  "    and call `exit(1)'!",
  "",
  "GDO_DELAYLOAD",
  "    Same as GDO_ENABLE_AUTOLOAD but only the requested symbol is loaded when its",
  "    wrapper function is called instead of all symbols.",
  "    It requires GDO_ENABLE_AUTOLOAD to be defined.",
  "",
  "GDO_AUTO_RELEASE",
  "    If defined the library handle will automatically be released on program exit.",
  "",
  "GDO_VISIBILITY",
  "    You can set the symbol visibility of wrapped functions (enabled with GDO_WRAP_FUNCTIONS)",
  "    using this macro.",
  "",
  "GDO_USE_MESSAGE_BOX",
  "    If win32 API is used and GDO_ENABLE_AUTOLOAD was activated this will enable",
  "    error messages from auto-loading to be displayed in MessageBox windows.",
  "",
  "GDO_DISABLE_ALIASING",
  "    Don't use preprocessor macros to alias symbol names. Use with care.",
  "",
  "GDO_DISABLE_DLINFO",
  "    Always disable usage of `dlinfo(3)'.",
  "",
  "GDO_DISABLE_DLMOPEN",
  "    Always disable usage of `dlmopen(3)'.",
  "",
  "",
  "",
  "*****************",
  "* Helper macros *",
  "*****************",
  "",
  "GDO_DEFAULT_FLAGS",
  "    Default flags for `dlopen()' or `LoadLibraryEx()'",
  "",
  "LIBNAME(NAME, API)",
  "LIBNAMEA(NAME, API)",
  "LIBNAMEW(NAME, API)",
  "    Convenience macro to create versioned library names for DLLs, dylibs and DSOs,",
  "    including double quote marks.",
  "    LIBNAME(z,1) for example will become \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\".",
  "",
  "LIBEXT",
  "LIBEXTA",
  "LIBEXTW",
  "    Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").",
  "    Useful i.e. on plugins.",
  "",
  "***/",
  "",
  "",
  "/*****************************************************************************/",
  "/*                                   C API                                   */",
  "/*****************************************************************************/",
  "",
  "",
  "/* static linkage */",
  "#ifdef GDO_STATIC",
  "# define GDO_LINKAGE  static",
  "#else",
  "# define GDO_LINKAGE  /**/",
  "#endif",
  "",
  "",
  "/* char / wchar_t */",
  "#if defined(GDO_WINAPI) && defined(_UNICODE)",
  "typedef wchar_t gdo_char_t;",
  "#else",
  "typedef char gdo_char_t;",
  "#endif",
  "",
  "",
  "/* Our library and symbols handle */",
  "typedef struct gdo_handle",
  "{",
  "#ifdef GDO_WINAPI",
  "    HMODULE handle;",
  "    DWORD last_errno;",
  "    /* FormatMessage: according to MSDN the maximum is either 64k or 128k */",
  "    gdo_char_t buf_formatted[64*1024];",
  "#else",
  "    void *handle;",
  "#endif",
  "    bool call_free_lib_is_registered;",
  "    gdo_char_t buf[8*1024];",
  "",
  "    /* symbols */",
  "    %%type%% (*%%func_symbol%%_ptr_)(%%args%%);",
  "    %%obj_type%% *%%obj_symbol%%_ptr_;",
  "",
  "} gdo_handle_t;",
  "",
  "extern GDO_LINKAGE gdo_handle_t gdo_hndl;",
  "",
  "",
  "#ifdef GDO_DEFAULT_LIB",
  "GDO_LINKAGE bool gdo_load_lib(void);",
  "GDO_LINKAGE bool gdo_load_lib_and_symbols(void);",
  "#endif",
  "GDO_LINKAGE bool gdo_load_lib_name(const gdo_char_t *filename);",
  "GDO_LINKAGE bool gdo_load_lib_name_and_symbols(const gdo_char_t *filename);",
  "GDO_LINKAGE bool gdo_load_lib_args(const gdo_char_t *filename, int flags, bool new_namespace);",
  "",
  "GDO_LINKAGE bool gdo_lib_is_loaded(void);",
  "GDO_LINKAGE bool gdo_free_lib(void);",
  "",
  "GDO_LINKAGE bool gdo_all_symbols_loaded(void);",
  "GDO_LINKAGE bool gdo_no_symbols_loaded(void);",
  "GDO_LINKAGE bool gdo_any_symbol_loaded(void);",
  "GDO_LINKAGE bool gdo_load_all_symbols(bool ignore_errors);",
  "GDO_LINKAGE bool gdo_load_symbol(const char *symbol);",
  "",
  "GDO_LINKAGE const gdo_char_t *gdo_last_error(void);",
  "GDO_LINKAGE gdo_char_t *gdo_lib_origin(void);",
  "",
  "",
  "/* aliases to raw function pointers */",
  "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)",
  "#define %%func_symbol%% gdo_hndl.%%func_symbol%%_ptr_",
  "#endif",
  "",
  "/* aliases to raw object pointers */",
  "#if !defined(GDO_DISABLE_ALIASING)",
  "#define %%obj_symbol%% *gdo_hndl.%%obj_symbol%%_ptr_",
  "#endif",
  NULL
};

/* c.c */
static const char *c_body[] = {
  "",
  "/*****************************************************************************/",
  "/*                           C API implementation                            */",
  "/*****************************************************************************/",
  "",
  "#if defined _MSC_VER && defined(GDO_USE_MESSAGE_BOX)",
  "# pragma comment(lib, \"user32.lib\")",
  "#endif",
  "",
  "#include <assert.h>",
  "#include <errno.h>",
  "#include <stdarg.h>",
  "#include <stdio.h>",
  "#include <stdlib.h>",
  "#include <string.h>",
  "",
  "#ifdef GDO_WINAPI",
  "# include <tchar.h>",
  "# ifdef _UNICODE",
  "#  define GDO_XS   L\"%ls\"",
  "#  define GDO_XHS  L\"%hs\"",
  "# endif",
  "#endif",
  "#ifndef GDO_XS",
  "# define GDO_XS   \"%s\"",
  "# define GDO_XHS  \"%s\"",
  "#endif",
  "",
  "#ifndef _T",
  "# define _T(x) x",
  "#endif",
  "#ifndef _countof",
  "# define _countof(array) (sizeof(array) / sizeof(array[0]))",
  "#endif",
  "",
  "",
  "#define GDO_SNPRINTF(dst, fmt, ...) \\",
  "    gdo_snprintf(dst, _countof(dst), fmt, __VA_ARGS__)",
  "",
  "#define GDO_STRLCPY(dst, src) \\",
  "    gdo_strlcpy(dst, src, _countof(dst))",
  "",
  "",
  "/* typedefs */",
  "typedef void GDO_UNUSED_REF;",
  "typedef void GDO_UNUSED_RESULT;",
  "",
  "",
  "/* library handle */",
  "GDO_LINKAGE gdo_handle_t gdo_hndl = {0};",
  "",
  "",
  "/* forward declarations */",
  "GDO_LINKAGE void gdo_load_library(const gdo_char_t *filename, int flags, bool new_namespace);",
  "GDO_LINKAGE void gdo_register_free_lib(void);",
  "GDO_LINKAGE void *gdo_sym(const char *symbol, const gdo_char_t *msg);",
  "#if !defined(GDO_WINAPI) && !defined(GDO_HAVE_DLINFO)",
  "GDO_LINKAGE char *gdo_dladdr_get_fname(const void *ptr);",
  "#endif",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                                save error                                 */",
  "/*****************************************************************************/",
  "",
  "/* simplified implementation of snprintf (based on NetBSD's version) */",
  "/*-",
  " * Copyright (c) 1990, 1993",
  " *\tThe Regents of the University of California.  All rights reserved.",
  " *",
  " * This code is derived from software contributed to Berkeley by",
  " * Chris Torek.",
  " *",
  " * Redistribution and use in source and binary forms, with or without",
  " * modification, are permitted provided that the following conditions",
  " * are met:",
  " * 1. Redistributions of source code must retain the above copyright",
  " *    notice, this list of conditions and the following disclaimer.",
  " * 2. Redistributions in binary form must reproduce the above copyright",
  " *    notice, this list of conditions and the following disclaimer in the",
  " *    documentation and/or other materials provided with the distribution.",
  " * 3. Neither the name of the University nor the names of its contributors",
  " *    may be used to endorse or promote products derived from this software",
  " *    without specific prior written permission.",
  " *",
  " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND",
  " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
  " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
  " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE",
  " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL",
  " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS",
  " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)",
  " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT",
  " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY",
  " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF",
  " * SUCH DAMAGE.",
  " */",
  "GDO_LINKAGE void gdo_snprintf(gdo_char_t *str, size_t buflen, const gdo_char_t *fmt, ...)",
  "{",
  "    /* max number of elements to write, not including the terminating NUL */",
  "    const size_t count = buflen - 1;",
  "",
  "    va_list ap;",
  "    va_start(ap, fmt);",
  "",
  "#ifdef GDO_WINAPI",
  "    _vsntprintf_s(str, buflen, count, fmt, ap);",
  "#else",
  "    vsnprintf(str, buflen, fmt, ap);",
  "#endif",
  "",
  "    va_end(ap);",
  "",
  "    /* just in case */",
  "    str[count] = 0;",
  "}",
  "",
  "/* simplified implementation of strlcpy (based on NetBSD's version) */",
  "/*",
  " * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>",
  " *",
  " * Permission to use, copy, modify, and distribute this software for any",
  " * purpose with or without fee is hereby granted, provided that the above",
  " * copyright notice and this permission notice appear in all copies.",
  " *",
  " * THE SOFTWARE IS PROVIDED \"AS IS\" AND TODD C. MILLER DISCLAIMS ALL",
  " * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES",
  " * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE",
  " * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES",
  " * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION",
  " * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN",
  " * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
  " */",
  "GDO_LINKAGE void gdo_strlcpy(gdo_char_t *dst, const gdo_char_t *src, size_t dst_len)",
  "{",
  "    gdo_char_t *dst_end = dst + (dst_len - 1);",
  "",
  "    while (dst != dst_end) {",
  "        if ((*dst++ = *src++) == 0) {",
  "            return;",
  "        }",
  "    }",
  "",
  "    *dst_end = 0;",
  "}",
  "",
  "/* save message to error buffer */",
  "GDO_LINKAGE void gdo_save_to_errbuf(const gdo_char_t *msg)",
  "{",
  "    if (msg) {",
  "        GDO_STRLCPY(gdo_hndl.buf, msg);",
  "    }",
  "}",
  "",
  "#ifdef GDO_WINAPI",
  "",
  "/* Clear error buffers. */",
  "GDO_LINKAGE void gdo_clear_errbuf(void)",
  "{",
  "    gdo_hndl.buf[0] = 0;",
  "    gdo_hndl.buf_formatted[0] = 0;",
  "    gdo_hndl.last_errno = 0;",
  "}",
  "",
  "/* Save the last system error code. A message for additional information",
  " * can be provided too. */",
  "GDO_LINKAGE void gdo_save_GetLastError(const gdo_char_t *msg)",
  "{",
  "    gdo_clear_errbuf();",
  "    gdo_hndl.last_errno = GetLastError();",
  "    gdo_save_to_errbuf(msg);",
  "}",
  "",
  "/* Sets the \"no library was loaded\" error message */",
  "GDO_LINKAGE void gdo_set_error_no_library_loaded(void)",
  "{",
  "    gdo_clear_errbuf();",
  "    gdo_hndl.last_errno = ERROR_INVALID_HANDLE;",
  "    gdo_save_to_errbuf(_T(\"no library was loaded\"));",
  "}",
  "",
  "#else",
  "/*********************************** dlfcn ***********************************/",
  "",
  "/* Clear error buffers. */",
  "GDO_LINKAGE void gdo_clear_errbuf(void)",
  "{",
  "    gdo_hndl.buf[0] = 0;",
  "}",
  "",
  "/* Save the last message provided by dlerror() */",
  "GDO_LINKAGE void gdo_save_dlerror(void)",
  "{",
  "    gdo_clear_errbuf();",
  "    gdo_save_to_errbuf(dlerror());",
  "}",
  "",
  "/* Sets the \"no library was loaded\" error message */",
  "GDO_LINKAGE void gdo_set_error_no_library_loaded(void)",
  "{",
  "    gdo_clear_errbuf();",
  "    gdo_save_to_errbuf(\"no library was loaded\");",
  "}",
  "",
  "#endif //!GDO_WINAPI",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                load default library with default flags                    */",
  "/*****************************************************************************/",
  "#ifdef GDO_DEFAULT_LIB",
  "GDO_LINKAGE bool gdo_load_lib(void)",
  "{",
  "    return gdo_load_lib_args(GDO_DEFAULT_LIB, GDO_DEFAULT_FLAGS, false);",
  "}",
  "#endif",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*       load default library with default flags and load the symbols        */",
  "/*****************************************************************************/",
  "#ifdef GDO_DEFAULT_LIB",
  "GDO_LINKAGE bool gdo_load_lib_and_symbols(void)",
  "{",
  "    return (gdo_load_lib_args(GDO_DEFAULT_LIB, GDO_DEFAULT_FLAGS, false) &&",
  "        gdo_load_all_symbols(false));",
  "}",
  "#endif",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*            load library by filename with default flags                    */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_load_lib_name(const gdo_char_t *filename)",
  "{",
  "    return gdo_load_lib_args(filename, GDO_DEFAULT_FLAGS, false);",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*     load library by filename with default flags and load the symbols      */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_load_lib_name_and_symbols(const gdo_char_t *filename)",
  "{",
  "    return (gdo_load_lib_name(filename) && gdo_load_all_symbols(false));",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                          load the library                                 */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_load_lib_args(const gdo_char_t *filename, int flags, bool new_namespace)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "    /* check if the library was already loaded */",
  "    if (gdo_lib_is_loaded()) {",
  "        return true;",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "    /* empty filename */",
  "    if (!filename || *filename == 0) {",
  "        gdo_clear_errbuf();",
  "        gdo_hndl.last_errno = ERROR_INVALID_NAME;",
  "        gdo_save_to_errbuf(_T(\"empty filename\"));",
  "        return false;",
  "    }",
  "",
  "    gdo_load_library(filename, flags, new_namespace);",
  "",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_save_GetLastError(filename);",
  "        return false;",
  "    }",
  "",
  "#else /* dlfcn */",
  "",
  "    /* an empty filename will actually return a handle to the main program,",
  "     * but we don't want that */",
  "    if (!filename || *filename == 0) {",
  "        gdo_clear_errbuf();",
  "        gdo_save_to_errbuf(\"empty filename\");",
  "        return false;",
  "    }",
  "",
  "#ifdef _AIX",
  "    errno = 0;",
  "    gdo_load_library(filename, flags, new_namespace);",
  "    int errsav = errno;",
  "",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_clear_errbuf();",
  "        const char *ptr = (errsav == ENOEXEC) ? dlerror() : strerror(errsav);",
  "        gdo_save_to_errbuf(ptr);",
  "    }",
  "#else",
  "    gdo_load_library(filename, flags, new_namespace);",
  "",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_save_dlerror();",
  "        return false;",
  "    }",
  "#endif //!_AIX",
  "",
  "#endif //!GDO_WINAPI",
  "",
  "    gdo_register_free_lib();",
  "",
  "    return true;",
  "}",
  "",
  "/* call LoadLibraryEx/dlopen/dlmopen */",
  "GDO_LINKAGE void gdo_load_library(const gdo_char_t *filename, int flags, bool new_namespace)",
  "{",
  "#ifdef GDO_WINAPI",
  "",
  "    (GDO_UNUSED_REF) new_namespace;",
  "    gdo_hndl.handle = LoadLibraryEx(filename, NULL, flags);",
  "",
  "#elif defined(GDO_HAVE_DLMOPEN)",
  "",
  "    /* call dlmopen() for new namespace, otherwise dlopen() */",
  "    if (new_namespace) {",
  "        gdo_hndl.handle = dlmopen(LM_ID_NEWLM, filename, flags);",
  "    } else {",
  "        gdo_hndl.handle = dlopen(filename, flags);",
  "    }",
  "",
  "#else",
  "",
  "    /* no dlmopen() */",
  "    (GDO_UNUSED_REF) new_namespace;",
  "    gdo_hndl.handle = dlopen(filename, flags);",
  "",
  "#endif //!GDO_WINAPI",
  "}",
  "",
  "/* If registered with atexit() this function will be called at",
  " * the program's exit. Function must be of type \"void (*)(void)\". */",
  "GDO_LINKAGE void gdo_call_free_lib(void)",
  "{",
  "    if (gdo_lib_is_loaded()) {",
  "#ifdef GDO_WINAPI",
  "        FreeLibrary(gdo_hndl.handle);",
  "#else",
  "        dlclose(gdo_hndl.handle);",
  "#endif",
  "    }",
  "}",
  "",
  "/* register our call to free the library handle with atexit()",
  " * so that the library will automatically be freed upon exit */",
  "GDO_LINKAGE void gdo_register_free_lib(void)",
  "{",
  "#ifdef GDO_AUTO_RELEASE",
  "    if (!gdo_hndl.call_free_lib_is_registered) {",
  "        atexit(gdo_call_free_lib);",
  "        gdo_hndl.call_free_lib_is_registered = true;",
  "    }",
  "#endif",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                whether the library is currently loaded                    */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_lib_is_loaded(void)",
  "{",
  "    return (gdo_hndl.handle != NULL);",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*          Free the library handle and set pointers to NULL                 */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_free_lib(void)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "    if (!gdo_lib_is_loaded()) {",
  "        /* nothing to free */",
  "        return true;",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "    if (FreeLibrary(gdo_hndl.handle) == FALSE) {",
  "        gdo_save_GetLastError(_T(\"FreeLibrary()\"));",
  "        return false;",
  "    }",
  "#else",
  "    if (dlclose(gdo_hndl.handle) != 0) {",
  "        gdo_save_dlerror();",
  "        return false;",
  "    }",
  "#endif",
  "",
  "    /* set pointers back to NULL */",
  "    gdo_hndl.handle = NULL;",
  "    gdo_hndl.%%symbol%%_ptr_ = NULL;",
  "",
  "    return true;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                    check if ALL symbols were loaded                       */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_all_symbols_loaded(void)",
  "{",
  "    if (true",
  "        && gdo_hndl.%%symbol%%_ptr_ != NULL",
  "    ) {",
  "        return true;",
  "    }",
  "",
  "    return false;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                    check if NO symbols were loaded                        */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_no_symbols_loaded(void)",
  "{",
  "    if (true",
  "        && gdo_hndl.%%symbol%%_ptr_ == NULL",
  "    ) {",
  "        return true;",
  "    }",
  "",
  "    return false;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                     check if ANY symbol was loaded                        */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_any_symbol_loaded(void)",
  "{",
  "    if (false",
  "        || gdo_hndl.%%symbol%%_ptr_ != NULL",
  "    ) {",
  "        return true;",
  "    }",
  "",
  "    return false;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*          load all symbols; can safely be called multiple times            */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_load_all_symbols(bool ignore_errors)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "    /* already loaded all symbols */",
  "    if (gdo_all_symbols_loaded()) {",
  "        return true;",
  "    }",
  "",
  "    /* no library was loaded */",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_set_error_no_library_loaded();",
  "        return false;",
  "    }",
  "",
  "    /* We can ignore errors in which case dlsym() or GetProcAddress()",
  "     * is called for each symbol and continue to do so even if it fails.",
  "     * The function will however in the end still return false if 1 or more",
  "     * symbols failed to load.",
  "     * If we do not ignore errors the function will simply return false on",
  "     * the first error it encounters. */",
  "",
  "    /* get symbol addresses */",
  "\n" /* multiline entry */
  "    /* %%symbol%% */\n"
  "    gdo_hndl.%%symbol%%_ptr_ = \n"
  "        (%%sym_type%%)\n"
  "            gdo_sym(\"%%symbol%%\", _T(\"%%symbol%%\"));\n"
  "    if (!gdo_hndl.%%symbol%%_ptr_ && !ignore_errors) {\n"
  "        return false;\n"
  "    }",
  "",
  "    gdo_clear_errbuf();",
  "",
  "    return gdo_all_symbols_loaded();",
  "}",
  "",
  "GDO_LINKAGE void *gdo_sym(const char *symbol, const gdo_char_t *msg)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "#ifdef GDO_WINAPI",
  "",
  "    /* cast to void* to supress compiler warnings */",
  "    void *ptr = (void *)GetProcAddress(gdo_hndl.handle, symbol);",
  "",
  "    if (!ptr) {",
  "        gdo_save_GetLastError(msg);",
  "    }",
  "",
  "#else",
  "",
  "    (GDO_UNUSED_REF) msg;",
  "",
  "    void *ptr = dlsym(gdo_hndl.handle, symbol);",
  "",
  "    /**",
  "     * Linux man page mentions cases where NULL pointer is a valid address.",
  "     * These however seem to be edge-cases that are irrelevant to us.",
  "     * Furthermore this is contradicting POSIX which says a NULL pointer shall",
  "     * be returned on an error.",
  "     */",
  "    if (!ptr) {",
  "        gdo_save_dlerror();",
  "    }",
  "",
  "#endif //!GDO_WINAPI",
  "",
  "    return ptr;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                        load a specific symbol                             */",
  "/*                                                                           */",
  "/* The main intention is to check if a certain symbol is present in a        */",
  "/* library so that you can conditionally enable or disable features.         */",
  "/*****************************************************************************/",
  "GDO_LINKAGE bool gdo_load_symbol(const char *symbol)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "    /* no library was loaded */",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_set_error_no_library_loaded();",
  "        return false;",
  "    }",
  "",
  "    /* empty symbol? */",
  "    if (!symbol) {",
  "        gdo_save_to_errbuf(_T(\"symbol == NULL\"));",
  "        return false;",
  "    }",
  "",
  "    if (symbol[0] == 0) {",
  "        gdo_save_to_errbuf(_T(\"'symbol' is empty\"));",
  "        return false;",
  "    }",
  "",
  "    /* opt out if symbol doesn't begin with prefix */",
  "    const char * const pfx = \"%COMMON_PREFIX%\";",
  "    const size_t len = sizeof(pfx) - 1;",
  "",
  "    if ((len == 1 && *symbol == *pfx) ||",
  "        (len > 1 && strncmp(symbol, pfx, len) == 0))",
  "    {",
  "        const char *ptr = symbol + len;",
  "\n" /* multiline entry */
  "        /* %%symbol%% */\n"
  "        if (strcmp((const char *)\"%%symbol%%\" + len, ptr) == 0) {\n"
  "            gdo_hndl.%%symbol%%_ptr_ =\n"
  "                (%%sym_type%%)\n"
  "                    gdo_sym(\"%%symbol%%\", _T(\"%%symbol%%\"));\n"
  "            return (gdo_hndl.%%symbol%%_ptr_ != NULL);\n"
  "        }",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "    gdo_hndl.last_errno = ERROR_NOT_FOUND;",
  "#endif",
  "",
  "    GDO_SNPRINTF(gdo_hndl.buf, _T(\"symbol not among lookup list: \") GDO_XHS, symbol);",
  "",
  "    return false;",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/* retrieve the last saved error message (can be an empty buffer)            */",
  "/*                                                                           */",
  "/* For WinAPI the message will be generated from an error code.              */",
  "/*****************************************************************************/",
  "GDO_LINKAGE const gdo_char_t *gdo_last_error(void)",
  "{",
  "#ifdef GDO_WINAPI",
  "    /* message was already saved */",
  "    if (gdo_hndl.buf_formatted[0] != 0) {",
  "        return gdo_hndl.buf_formatted;",
  "    }",
  "",
  "    gdo_char_t *buf = NULL;",
  "    gdo_char_t *msg = gdo_hndl.buf;",
  "",
  "    /* format the message */",
  "    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |",
  "                    FORMAT_MESSAGE_FROM_SYSTEM |",
  "                    FORMAT_MESSAGE_MAX_WIDTH_MASK,",
  "                NULL, gdo_hndl.last_errno, 0, (LPTSTR)&buf, 0, NULL);",
  "",
  "    if (buf) {",
  "        /* put custom message in front of system error message */",
  "        if (msg[0] != 0 && (_tcslen(buf) + _tcslen(msg) + 2) <",
  "            _countof(gdo_hndl.buf_formatted))",
  "        {",
  "            GDO_SNPRINTF(gdo_hndl.buf_formatted, GDO_XS _T(\": \") GDO_XS, msg, buf);",
  "        } else {",
  "            GDO_STRLCPY(gdo_hndl.buf_formatted, buf);",
  "        }",
  "        LocalFree(buf);",
  "    } else {",
  "        /* FormatMessage() failed, save the error code */",
  "        GDO_SNPRINTF(gdo_hndl.buf_formatted, _T(\"Last saved error code: %lu\"), gdo_hndl.last_errno);",
  "    }",
  "",
  "    return gdo_hndl.buf_formatted;",
  "#else",
  "    /* simply return the buffer */",
  "    return gdo_hndl.buf;",
  "#endif //GDO_WINAPI",
  "}",
  "/*****************************************************************************/",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                       get the full library path                           */",
  "/*                                                                           */",
  "/* Result must be deallocated with free(), returns NULL on error.            */",
  "/*****************************************************************************/",
  "GDO_LINKAGE gdo_char_t *gdo_lib_origin(void)",
  "{",
  "    gdo_clear_errbuf();",
  "",
  "    /* check if library was loaded */",
  "    if (!gdo_lib_is_loaded()) {",
  "        gdo_set_error_no_library_loaded();",
  "        return NULL;",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "    gdo_char_t *origin;",
  "    DWORD len = 260; /* MAX_PATH */",
  "",
  "    /* allocate enough space */",
  "    origin = (gdo_char_t *)malloc(len * sizeof(gdo_char_t));",
  "    assert(origin != NULL);",
  "",
  "    /* receive path from handle */",
  "    if (GetModuleFileName(gdo_hndl.handle, origin, len-1) == 0) {",
  "        gdo_save_GetLastError(_T(\"GetModuleFileName\"));",
  "        free(origin);",
  "        return NULL;",
  "    }",
  "",
  "    /* https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation",
  "     * technically the path could exceed 260 characters, but in reality",
  "     * it's practically still stuck at the old MAX_PATH value */",
  "    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {",
  "        len = 32*1024;",
  "        origin = (gdo_char_t *)realloc(origin, len * sizeof(gdo_char_t));",
  "        assert(origin != NULL);",
  "",
  "        if (GetModuleFileName(gdo_hndl.handle, origin, len-1) == 0) {",
  "            gdo_save_GetLastError(_T(\"GetModuleFileName\"));",
  "            free(origin);",
  "            return NULL;",
  "        }",
  "    }",
  "",
  "    return origin;",
  "#elif defined(GDO_HAVE_DLINFO)",
  "    /* use dlinfo() to get a link map */",
  "    struct link_map *lm = NULL;",
  "    //%DNL%// fprintf(stderr, \"DEBUG: using dlinfo()\\n\");",
  "",
  "    if (dlinfo(gdo_hndl.handle, RTLD_DI_LINKMAP, &lm) == -1) {",
  "        gdo_save_dlerror();",
  "        return NULL;",
  "    }",
  "",
  "    return lm->l_name ? strdup(lm->l_name) : NULL;",
  "#else",
  "    /* use dladdr() to get the library path from a symbol pointer */",
  "    char *fname;",
  "    //%DNL%// fprintf(stderr, \"DEBUG: using dladdr()\\n\");",
  "",
  "    if (gdo_no_symbols_loaded()) {",
  "        gdo_save_to_errbuf(\"no symbols were loaded\");",
  "        return NULL;",
  "    }",
  "",
  "    fname = gdo_dladdr_get_fname((void *)gdo_hndl.%%symbol%%_ptr_);\n" /* multiline entry */
  "    if (fname) return fname;",
  "",
  "    gdo_save_to_errbuf(\"dladdr() failed to get library path\");",
  "",
  "    return NULL;",
  "#endif //GDO_WINAPI",
  "}",
  "",
  "#if !defined(GDO_WINAPI) && !defined(GDO_HAVE_DLINFO)",
  "GDO_LINKAGE char *gdo_dladdr_get_fname(const void *ptr)",
  "{",
  "    Dl_info info;",
  "",
  "    if (ptr && dladdr(ptr, &info) != 0 && info.dli_fname) {",
  "        return strdup(info.dli_fname);",
  "    }",
  "",
  "    return NULL;",
  "}",
  "#endif // !GDO_WINAPI && !GDO_HAVE_DLINFO",
  "/*****************************************************************************/",
  "%PARAM_SKIP_REMOVE_BEGIN%",
  "",
  "",
  "",
  "/*****************************************************************************/",
  "/*                                wrap code                                  */",
  "/*****************************************************************************/",
  "#if defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)",
  "",
  "",
  "GDO_LINKAGE void gdo_error_exit(const gdo_char_t *msg)",
  "{",
  "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)",
  "    MessageBox(NULL, msg, _T(\"Error\"), MB_OK | MB_ICONERROR);",
  "#elif defined(_WIN32) && defined(_UNICODE)",
  "    fwprintf(stderr, L\"%ls\\n\", msg);",
  "#else",
  "    fprintf(stderr, \"%s\\n\", msg);",
  "#endif",
  "",
  "    gdo_free_lib();",
  "    exit(1);",
  "}",
  "",
  "",
  "/* function wrappers */",
  "\n" /* multiline entry */
  "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
  "    if (!gdo_hndl.%%func_symbol%%_ptr_) {\n"
  "        gdo_error_exit(\"error: symbol `%%func_symbol%%' was not loaded\");\n"
  "    }\n"
  "    %%return%% gdo_hndl.%%func_symbol%%_ptr_(%%notype_args%%);\n"
  "}",
  "",
  "",
  "#elif defined(GDO_ENABLE_AUTOLOAD)",
  "",
  "",
  "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)",
  "/* Windows: show message in a MessageBox window */",
  "GDO_LINKAGE void gdo_win32_last_error_messagebox(const gdo_char_t *symbol)",
  "{",
  "    const gdo_char_t *fmt = _T(\"error in wrapper function for symbol\")",
  "        _T(\"`\") GDO_XS _T(\"':\\n\\n\") GDO_XS;",
  "",
  "    const gdo_char_t *err = gdo_last_error();",
  "",
  "    const size_t buflen = _tcslen(fmt) + _tcslen(symbol) + _tcslen(err) + 1;",
  "    gdo_char_t *buf = (gdo_char_t *)malloc(buflen * sizeof(gdo_char_t));",
  "    assert(buf != NULL);",
  "",
  "    gdo_snprintf(buf, buflen, fmt, symbol, err);",
  "    MessageBox(NULL, buf, _T(\"Error\"), MB_OK | MB_ICONERROR);",
  "",
  "    free(buf);",
  "}",
  "#endif //_WIN32 && GDO_USE_MESSAGE_BOX",
  "",
  "",
  "/* This function is used by the wrapper functions to perform the loading",
  " * and handle errors. */",
  "GDO_LINKAGE void gdo_quick_load(const char *function, const gdo_char_t *symbol)",
  "{",
  "#ifdef GDO_DELAYLOAD",
  "    /* load library + requested symbol */",
  "    if (gdo_load_lib() && gdo_load_symbol(function)) {",
  "        return;",
  "    }",
  "#else",
  "    (GDO_UNUSED_REF) function;",
  "",
  "    /* return immediately if everything is already loaded,",
  "     * otherwise load library + all symbols */",
  "    if (gdo_all_symbols_loaded() || gdo_load_lib_and_symbols()) {",
  "        return;",
  "    }",
  "#endif",
  "",
  "    /* an error has occured: display an error message */",
  "",
  "#if defined(_WIN32) && defined(GDO_USE_MESSAGE_BOX)",
  "    /* Windows: popup message box window */",
  "    gdo_win32_last_error_messagebox(symbol);",
  "#elif defined(_WIN32) && defined(_UNICODE)",
  "    /* Windows: output to console (wide characters) */",
  "    fwprintf(stderr, L\"error in wrapper function for symbol `%ls':\\n%ls\\n\",",
  "        symbol, gdo_last_error());",
  "#else",
  "    /* default: UTF-8 output to console (any operating system) */",
  "    fprintf(stderr, \"error in wrapper function for symbol `%s':\\n%s\\n\",",
  "        symbol, gdo_last_error());",
  "#endif //_WIN32 && GDO_USE_MESSAGE_BOX",
  "",
  "    /* free library handle and exit */",
  "    gdo_free_lib();",
  "    exit(1);",
  "}",
  "",
  "",
  "/* autoload function wrappers */",
  "\n" /* multiline entry */
  "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
  "    gdo_quick_load(\"%%func_symbol%%\", _T(\"%%func_symbol%%\"));\n"
  "    %%return%% gdo_hndl.%%func_symbol%%_ptr_(%%notype_args%%);\n"
  "}",
  "",
  "#endif //GDO_ENABLE_AUTOLOAD",
  "/***************************** end of wrap code ******************************/",
  "%PARAM_SKIP_END%",
  NULL
};

/* cxx.hpp */
static const char *cxx_header[] = {
  "#if 0",
  "",
  "namespace gdo",
  "{",
  "",
  "class dl",
  "{",
  "public:",
  "",
  "    using message_callback_t = void (*)(const char *);",
  "",
  "",
  "    /* default flags */",
  "    static constexpr const int default_flags;",
  "",
  "",
  "    /* Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").",
  "     * Useful i.e. on plugins. */",
  "    static constexpr const char * const libext;",
  "",
  "",
  "    /* c'tor */",
  "    dl();",
  "    dl(const std::string &filename, int flags=default_flags, bool new_namespace=false);",
  "",
  "",
  "    /* d'tor */",
  "    ~dl();",
  "",
  "",
  "    /* Load the library; `filename' and `flags' are passed to the underlying library",
  "     * loading functions.",
  "     *",
  "     * If `new_namespace' is true the library will be loaded into a new namespace.",
  "     * This is done using dlmopen() (if available on the platform) with the",
  "     * LM_ID_NEWLM argument. */",
  "    bool load(const std::string &filename, int flags=default_flags, bool new_namespace=false);",
  "#ifdef GDO_WINAPI",
  "    bool load(const std::wstring &filename, int flags=default_flags, bool unused=false);",
  "#endif",
  "",
  "",
  "    /* Load the library.",
  "     * Filename and flags must have been set with the the constructor. */",
  "    bool load();",
  "",
  "",
  "    /* Load library from a list.",
  "     * T should be of a container type like std::vector, std::list, std::array, ... */",
  "    bool load_from_list(const T &list, int flags=default_flags, bool new_namespace=false)",
  "",
  "",
  "    /* Load library and symbols.",
  "     * Filename and flags must have been set with the the constructor. */",
  "    bool load_lib_and_symbols();",
  "",
  "",
  "    /* check if the library is loaded */",
  "    bool lib_loaded();",
  "",
  "",
  "    /* return the flags used to load the library */",
  "    int flags();",
  "",
  "",
  "    /* Load the symbols. This function can safely be called multiple times.",
  "     * If ignore_errors is set true the function won't stop on the first",
  "     * symbol that can't be loaded but instead tries to load them all.",
  "     * If one or more symbols weren't loaded the function returns false. */",
  "    bool load_all_symbols(bool ignore_errors=false);",
  "",
  "",
  "    /* load a specific symbol */",
  "    bool load_symbol(const std::string &symbol);",
  "",
  "",
  "    /* check if ALL symbols were loaded */",
  "    bool all_symbols_loaded();",
  "",
  "",
  "    /* check if NO symbols were loaded */",
  "    bool no_symbols_loaded();",
  "",
  "",
  "    /* check if ANY symbol was loaded */",
  "    bool any_symbol_loaded();",
  "",
  "",
  "    /* free library */",
  "    bool free();",
  "",
  "",
  "    /* whether to free the library in the class destructor */",
  "    void free_lib_in_dtor(bool b);",
  "",
  "",
  "",
  "    /* Create versioned library names for DLLs, dylibs and DSOs.",
  "     * make_libname(\"z\",1) for example will return \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\" */",
  "    static std::string make_libname(const std::string &name, unsigned int api);",
  "#ifdef GDO_WINAPI",
  "    static std::wstring make_libname(const std::wstring &name, unsigned int api);",
  "#endif",
  "",
  "",
  "#if defined(GDO_WRAP_FUNCTIONS) || defined(GDO_ENABLE_AUTOLOAD)",
  "",
  "    /* Set a message callback function to be used if an error occurred",
  "     * in a wrapped function. */",
  "    static void message_callback(message_callback_t cb);",
  "",
  "",
  "    /* Get a pointer to the message callback function. */",
  "    static message_callback_t message_callback();",
  "",
  "#endif // GDO_WRAP_FUNCTIONS || GDO_ENABLE_AUTOLOAD",
  "",
  "",
  "    /* get path of loaded library */",
  "    std::string origin();",
  "#ifdef GDO_WINAPI",
  "    std::wstring origin_w();",
  "#endif",
  "",
  "    /* retrieve the last error */",
  "#ifdef GDO_WINAPI",
  "    std::string error();",
  "    std::wstring error_w();",
  "#else",
  "    std::string error() const;",
  "#endif",
  "",
  "    /* get filename passed to load */",
  "#ifdef GDO_WINAPI",
  "    std::string filename();",
  "    std::wstring filename_w();",
  "#else",
  "    std::string filename() const;",
  "#endif",
  "",
  "}; /* class */",
  "",
  "} /* namespace */",
  "",
  "#endif // 0",
  "",
  "",
  "/***",
  "",
  "****************************************************",
  "* The following options may be set through macros: *",
  "****************************************************",
  "",
  "GDO_USE_DLOPEN",
  "    If defined `dlopen()' API is used on win32 targets.",
  "    On other targets `dlopen()' is always used.",
  "",
  "GDO_DEFAULT_FLAGS",
  "    Override the default flags to use when loading a library.",
  "",
  "GDO_DEFAULT_LIB",
  "    Set a default library name through this macro (including double quote",
  "    marks). This macro must be defined if you want to set GDO_ENABLE_AUTOLOAD.",
  "",
  "GDO_WRAP_FUNCTIONS",
  "    Use actual wrapped functions instead of a name alias. This is useful if you",
  "    want to create a library to later link an application against.",
  "",
  "GDO_ENABLE_AUTOLOAD",
  "    Define this macro if you want to use auto-loading wrapper functions.",
  "    This means you don't need to explicitly call library load functions.",
  "    The first wrapper function called will load all symbols at once.",
  "    It requires GDO_DEFAULT_LIB to be defined.",
  "    If an error occures during loading these functions print an error message",
  "    and call `std::exit(1)'!",
  "",
  "GDO_DELAYLOAD",
  "    Same as GDO_ENABLE_AUTOLOAD but only the requested symbol is loaded when its",
  "    wrapper function is called instead of all symbols.",
  "    It requires GDO_ENABLE_AUTOLOAD to be defined.",
  "",
  "GDO_VISIBILITY",
  "    You can set the symbol visibility of wrapped functions (enabled with",
  "    GDO_WRAP_FUNCTIONS) using this macro.",
  "",
  "GDO_DISABLE_ALIASING",
  "    Don't use preprocessor macros to alias symbol names. Use with care.",
  "",
  "GDO_DISABLE_DLINFO",
  "    Always disable usage of `dlinfo(3)'.",
  "",
  "GDO_DISABLE_DLMOPEN",
  "    Always disable usage of `dlmopen(3)'.",
  "",
  "***/",
  "",
  "#include <iostream>",
  "#include <string>",
  "#include <errno.h>",
  "#include <stdlib.h>",
  "#include <string.h>",
  "",
  "",
  "",
  "namespace gdo",
  "{",
  "",
  "/*****************************************************************************/",
  "/*                          library loader class                             */",
  "/*****************************************************************************/",
  "class dl",
  "{",
  "public:",
  "",
  "    using message_callback_t = void (*)(const char *);",
  "",
  "",
  "    /* default flags */",
  "    static constexpr const int default_flags = GDO_DEFAULT_FLAGS;",
  "",
  "    /* Shared library file extension without dot (\"dll\", \"dylib\" or \"so\").",
  "     * Useful i.e. on plugins. */",
  "    static constexpr const char * const libext = LIBEXTA;",
  "",
  "    /* symbol pointers */",
  "    static %%type%% (*m_ptr_%%func_symbol%%)(%%args%%);",
  "    static %%obj_type%% *m_ptr_%%obj_symbol%%;",
  "",
  "",
  "private:",
  "",
  "    using UNUSED_REF = void;",
  "    using UNUSED_RESULT = void;",
  "",
  "#ifdef GDO_HAS_MSG_CB",
  "    /* function pointer to error message callback */",
  "    static message_callback_t m_message_callback;",
  "#endif",
  "",
  "    std::string m_filename;",
  "    int m_flags = default_flags;",
  "    bool m_new_namespace = false;",
  "    bool m_free_lib_in_dtor = true;",
  "",
  "#ifdef GDO_WINAPI",
  "",
  "    template<typename T>",
  "    T function_cast(FARPROC proc) {",
  "        /* cast to void* to supress compiler warnings */",
  "        return reinterpret_cast<T>(reinterpret_cast<void *>(proc));",
  "    }",
  "",
  "    /* library handle */",
  "    using handle_t = HMODULE;",
  "    static handle_t m_handle;",
  "",
  "    /* error message */",
  "    DWORD m_last_error = 0;",
  "    std::string m_errmsg;",
  "    std::wstring m_werrmsg;",
  "    std::wstring m_wfilename;",
  "",
  "",
  "    /* wstring to string */",
  "    static std::string wstr_to_str(const std::wstring &wstr)",
  "    {",
  "        size_t len, n;",
  "        char *buf;",
  "        std::string str;",
  "",
  "        if (wstr.empty()) {",
  "            return {};",
  "        }",
  "",
  "        if (::wcstombs_s(&len, nullptr, 0, wstr.c_str(), 0) != 0 || len == 0) {",
  "            return {};",
  "        }",
  "",
  "        buf = new char[len + 1];",
  "        if (!buf) return {};",
  "",
  "        if (::wcstombs_s(&n, buf, len+1, wstr.c_str(), len) != 0 || n == 0) {",
  "            return {};",
  "        }",
  "",
  "        buf[len] = '\\0';",
  "        str = buf;",
  "        delete[] buf;",
  "",
  "        return str;",
  "    }",
  "",
  "",
  "    /* string to wstring */",
  "    static std::wstring str_to_wstr(const std::string &str)",
  "    {",
  "        size_t len, n;",
  "        wchar_t *buf;",
  "        std::wstring wstr;",
  "",
  "        if (str.empty()) {",
  "            return {};",
  "        }",
  "",
  "        if (::mbstowcs_s(&len, nullptr, 0, str.c_str(), 0) != 0 || len == 0) {",
  "            return {};",
  "        }",
  "",
  "        buf = new wchar_t[(len + 1) * sizeof(wchar_t)];",
  "        if (!buf) return {};",
  "",
  "        if (::mbstowcs_s(&n, buf, len+1, str.c_str(), len) != 0 || n == 0) {",
  "            delete[] buf;",
  "            return {};",
  "        }",
  "",
  "        buf[len] = L'\\0';",
  "        wstr = buf;",
  "        delete[] buf;",
  "",
  "        return wstr;",
  "    }",
  "",
  "",
  "    /* clear error */",
  "    void clear_error()",
  "    {",
  "        m_errmsg.clear();",
  "        m_werrmsg.clear();",
  "        m_last_error = 0;",
  "    }",
  "",
  "",
  "    /* save last error (no extra message) */",
  "    void save_error()",
  "    {",
  "        m_last_error = ::GetLastError();",
  "        m_errmsg.clear();",
  "        m_werrmsg.clear();",
  "    }",
  "",
  "",
  "    /* save last error (narrow char message) */",
  "    void save_error(const std::string &msg)",
  "    {",
  "        m_last_error = ::GetLastError();",
  "        m_errmsg = msg;",
  "        m_werrmsg.clear();",
  "    }",
  "",
  "",
  "    /* save last error (wide char message) */",
  "    void save_error(const std::wstring &msg)",
  "    {",
  "        m_last_error = ::GetLastError();",
  "        m_errmsg.clear();",
  "        m_werrmsg = msg;",
  "    }",
  "",
  "",
  "    /* if m_handle is NULL */",
  "    void set_error_invalid_handle()",
  "    {",
  "        clear_error();",
  "        m_last_error = ERROR_INVALID_HANDLE;",
  "    }",
  "",
  "",
  "    /* if filename is empty */",
  "    void set_error_empty_filename()",
  "    {",
  "        clear_error();",
  "        m_last_error = ERROR_INVALID_NAME;",
  "        m_errmsg = \"empty filename\";",
  "    }",
  "",
  "",
  "    /* load library */",
  "    void load_lib(const char *filename, int flags, bool /*unused*/)",
  "    {",
  "        m_wfilename.clear();",
  "        m_filename = filename;",
  "        m_flags = flags;",
  "",
  "        m_handle = ::LoadLibraryExA(filename, nullptr, m_flags);",
  "    }",
  "",
  "",
  "    /* free library handle */",
  "    bool free_lib()",
  "    {",
  "        return (::FreeLibrary(m_handle) == TRUE);",
  "    }",
  "",
  "",
  "    /* load symbol address */",
  "    template<typename T>",
  "    T sym(const char *symbol)",
  "    {",
  "        clear_error();",
  "",
  "        T proc = function_cast<T>(::GetProcAddress(m_handle, symbol));",
  "",
  "        if (!proc) {",
  "            save_error(symbol);",
  "        }",
  "",
  "        return proc;",
  "    }",
  "",
  "",
  "    inline DWORD get_module_filename(HMODULE handle, wchar_t *buf, DWORD len) {",
  "        return ::GetModuleFileNameW(handle, buf, len);",
  "    }",
  "",
  "    inline DWORD get_module_filename(HMODULE handle, char *buf, DWORD len) {",
  "        return ::GetModuleFileNameA(handle, buf, len);",
  "    }",
  "",
  "",
  "    /* get the module's full path using GetModuleFileName() */",
  "    template<typename T>",
  "    std::basic_string<T> get_origin_from_module_handle()",
  "    {",
  "        if (!lib_loaded()) {",
  "            set_error_invalid_handle();",
  "            return {};",
  "        }",
  "",
  "        DWORD len = 260; /* MAX_PATH */",
  "        T *origin = new T[len * sizeof(T)]();",
  "        ::memset(origin, 0, len * sizeof(T));",
  "",
  "        if (get_module_filename(m_handle, origin, len-1) == 0) {",
  "            save_error();",
  "            delete[] origin;",
  "            return {};",
  "        }",
  "",
  "        /* https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation",
  "         * technically the path could exceed 260 characters, but in reality",
  "         * it's practically still stuck at the old MAX_PATH value */",
  "        if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {",
  "            delete[] origin;",
  "",
  "            len = 32*1024;",
  "            origin = new T[len * sizeof(T)]();",
  "            ::memset(origin, 0, len * sizeof(T));",
  "",
  "            if (get_module_filename(m_handle, origin, len-1) == 0) {",
  "                save_error();",
  "                delete[] origin;",
  "                return {};",
  "            }",
  "        }",
  "",
  "        std::basic_string<T> str = origin;",
  "        delete[] origin;",
  "",
  "        return str;",
  "    }",
  "",
  "",
  "    inline DWORD format_message(DWORD flags, DWORD msgId, LPWSTR buf) {",
  "        return ::FormatMessageW(flags, NULL, msgId, 0, buf, 0, NULL);",
  "    }",
  "",
  "    inline DWORD format_message(DWORD flags, DWORD msgId, LPSTR buf) {",
  "        return ::FormatMessageA(flags, NULL, msgId, 0, buf, 0, NULL);",
  "    }",
  "",
  "",
  "    /* return a formatted error message */",
  "    template<typename T>",
  "    std::basic_string<T> format_last_error_message()",
  "    {",
  "        std::basic_string<T> str;",
  "        T *buf = nullptr;",
  "",
  "        const DWORD flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |",
  "                            FORMAT_MESSAGE_FROM_SYSTEM |",
  "                            FORMAT_MESSAGE_MAX_WIDTH_MASK;",
  "",
  "        format_message(flags, m_last_error, reinterpret_cast<T*>(&buf));",
  "",
  "        if (buf) {",
  "            str = buf;",
  "            ::LocalFree(buf);",
  "        }",
  "",
  "        return str;",
  "    }",
  "",
  "",
  "#else",
  "/*********************************** dlfcn ***********************************/",
  "",
  "",
  "    /* library handle */",
  "    using handle_t = void*;",
  "    static handle_t m_handle;",
  "",
  "    /* error message */",
  "    std::string m_errmsg;",
  "",
  "",
  "    /* clear error */",
  "    void clear_error()",
  "    {",
  "        m_errmsg.clear();",
  "        (UNUSED_RESULT) ::dlerror();",
  "    }",
  "",
  "",
  "    /* save last error */",
  "    void save_error()",
  "    {",
  "        auto ptr = ::dlerror();",
  "        m_errmsg = ptr ? ptr : \"\";",
  "    }",
  "",
  "    void save_error(const std::string&)",
  "    {",
  "        save_error();",
  "    }",
  "",
  "",
  "    /* if m_handle is NULL */",
  "    void set_error_invalid_handle()",
  "    {",
  "        clear_error();",
  "        m_errmsg = \"no library was loaded\";",
  "    }",
  "",
  "",
  "    /* if filename is empty */",
  "    void set_error_empty_filename()",
  "    {",
  "        clear_error();",
  "        m_errmsg = \"empty filename\";",
  "    }",
  "",
  "",
  "    /* load library */",
  "    void load_lib(const char *filename, int flags, bool new_namespace)",
  "    {",
  "        m_flags = flags;",
  "        m_filename = filename;",
  "",
  "#ifdef GDO_HAVE_DLMOPEN",
  "        /* dlmopen() for new namespace or dlopen() */",
  "        if (new_namespace) {",
  "            m_handle = ::dlmopen(LM_ID_NEWLM, filename, m_flags);",
  "        } else {",
  "            m_handle = ::dlopen(filename, m_flags);",
  "        }",
  "#else",
  "        /* no dlmopen() */",
  "        (UNUSED_REF) new_namespace;",
  "        m_handle = ::dlopen(filename, m_flags);",
  "#endif",
  "    }",
  "",
  "",
  "    /* free library handle */",
  "    bool free_lib()",
  "    {",
  "        return (::dlclose(m_handle) == 0);",
  "    }",
  "",
  "",
  "    /* load symbol address */",
  "    template<typename T>",
  "    T sym(const char *symbol)",
  "    {",
  "        clear_error();",
  "",
  "        T ptr = reinterpret_cast<T>(::dlsym(m_handle, symbol));",
  "",
  "        /**",
  "        * Linux man page mentions cases where NULL pointer is a valid address.",
  "        * These however seem to be edge-cases that are irrelevant to us.",
  "        * Furthermore this is contradicting POSIX which says a NULL pointer shall",
  "        * be returned on an error.",
  "        */",
  "        if (!ptr) {",
  "            save_error();",
  "        }",
  "",
  "        return ptr;",
  "    }",
  "",
  "#endif // !GDO_WINAPI",
  "",
  "",
  "public:",
  "",
  "    /* c'tor (empty) */",
  "    dl()",
  "    {}",
  "",
  "",
  "    /* c'tor (set filename) */",
  "    dl(const std::string &filename, int flags=default_flags, bool new_namespace=false)",
  "      : m_filename(filename),",
  "        m_flags(flags),",
  "        m_new_namespace(new_namespace)",
  "    {}",
  "",
  "",
  "    /* d'tor */",
  "    virtual ~dl()",
  "    {",
  "        if (m_free_lib_in_dtor && lib_loaded()) {",
  "            free_lib();",
  "        }",
  "    }",
  "",
  "",
  "    /* load library */",
  "    bool load(const std::string &filename, int flags=default_flags, bool new_namespace=false)",
  "    {",
  "        /* release old libhandle */",
  "        if (lib_loaded() && !free()) {",
  "            return false;",
  "        }",
  "",
  "        if (filename.empty()) {",
  "            set_error_empty_filename();",
  "            return false;",
  "        }",
  "",
  "        clear_error();",
  "",
  "#ifdef _AIX",
  "        errno = 0;",
  "        load_lib(filename.c_str(), flags, new_namespace);",
  "        int errsav = errno;",
  "",
  "        if (!lib_loaded()) {",
  "            const char *ptr = (errsav == ENOEXEC) ? ::dlerror() : ::strerror(errsav);",
  "            m_errmsg = ptr ? ptr : \"\";",
  "        }",
  "#else",
  "        load_lib(filename.c_str(), flags, new_namespace);",
  "        save_error(filename);",
  "#endif //!_AIX",
  "",
  "        return lib_loaded();",
  "    }",
  "",
  "",
  "#ifdef GDO_WINAPI",
  "    /* load library (wide characters version) */",
  "    bool load(const std::wstring &filename, int flags=default_flags, bool unused=false)",
  "    {",
  "        (UNUSED_REF) unused;",
  "",
  "        /* release old libhandle */",
  "        if (lib_loaded() && !free()) {",
  "            return false;",
  "        }",
  "",
  "        if (filename.empty()) {",
  "            set_error_empty_filename();",
  "            return false;",
  "        }",
  "",
  "        clear_error();",
  "",
  "        m_filename.clear();",
  "        m_wfilename = filename;",
  "        m_flags = flags;",
  "",
  "        m_handle = ::LoadLibraryExW(filename.c_str(), NULL, m_flags);",
  "        save_error(filename);",
  "",
  "        return lib_loaded();",
  "    }",
  "#endif //GDO_WINAPI",
  "",
  "",
  "    /* load library */",
  "    bool load()",
  "    {",
  "        return load(m_filename, m_flags, m_new_namespace);",
  "    }",
  "",
  "",
  "    /* load from a container list of filenames (std::vector, std::list, etc.) */",
  "    template<class T>",
  "    bool load_from_list(const T &list, int flags=default_flags, bool new_namespace=false)",
  "    {",
  "        for (const auto &e : list) {",
  "            if (load(e, flags, new_namespace)) {",
  "                return true;",
  "            }",
  "        }",
  "",
  "        return false;",
  "    }",
  "",
  "",
  "    /* load library and symbols */",
  "    bool load_lib_and_symbols()",
  "    {",
  "        return (load() && load_all_symbols());",
  "    }",
  "",
  "",
  "    /* check if library is loaded */",
  "    bool lib_loaded() const",
  "    {",
  "        return (m_handle != nullptr);",
  "    }",
  "",
  "",
  "    /* return the flags used to load the library */",
  "    int flags() const",
  "    {",
  "        return m_flags;",
  "    }",
  "",
  "",
  "    /* load all symbols */",
  "    bool load_all_symbols(bool ignore_errors=false)",
  "    {",
  "        clear_error();",
  "",
  "        if (all_symbols_loaded()) {",
  "            return true;",
  "        } else if (!lib_loaded()) {",
  "            set_error_invalid_handle();",
  "            return false;",
  "        }",
  "",
  "        /* We can ignore errors in which case dlsym() or GetProcAddress()",
  "         * is called for each symbol and continue to do so even if it fails.",
  "         * The function will however in the end still return false if 1 or more",
  "         * symbols failed to load.",
  "         * If we do not ignore errors the function will simply return false on",
  "         * the first error it encounters. */",
  "",
  "        /* get symbol addresses */",
  "\n" /* multiline entry */
  "        /* %%symbol%% */\n"
  "        m_ptr_%%symbol%% =\n"
  "            sym<%%sym_type%%>\n"
  "                (\"%%symbol%%\");\n"
  "        if (!m_ptr_%%symbol%% && !ignore_errors) {\n"
  "            return false;\n"
  "        }",
  "",
  "        clear_error();",
  "",
  "        return all_symbols_loaded();",
  "    }",
  "",
  "",
  "    /* load a specific symbol */",
  "    bool load_symbol(const std::string &symbol)",
  "    {",
  "        auto err_not_found = [&] ()",
  "        {",
  "# ifdef GDO_WINAPI",
  "            m_last_error = ERROR_NOT_FOUND;",
  "# endif",
  "            m_errmsg = \"symbol not among lookup list: \" + symbol;",
  "        };",
  "",
  "        clear_error();",
  "",
  "        if (!lib_loaded()) {",
  "            set_error_invalid_handle();",
  "            return false;",
  "        }",
  "",
  "        /* empty symbol? */",
  "        if (symbol.empty()) {",
  "#ifdef GDO_WINAPI",
  "            m_last_error = ERROR_INVALID_PARAMETER;",
  "#endif",
  "            m_errmsg = \"empty symbol name\";",
  "            return false;",
  "        }",
  "",
  "        /* opt out if symbol doesn't begin with prefix */",
  "        const char * const pfx = \"%COMMON_PREFIX%\";",
  "        const size_t len = sizeof(pfx) - 1;",
  "",
  "        if (len == 0 || (len == 1 && symbol[0] != pfx[0]) ||",
  "            (len > 1 && strncmp(symbol.c_str(), pfx, len) != 0))",
  "        {",
  "            //%DNL%// std::cerr << \"DEBUG: not a common symbol prefix\" << std::endl;",
  "            err_not_found();",
  "            return false;",
  "        }",
  "",
  "        /* get symbol address */",
  "        const char * const ptr = symbol.c_str() + len;",
  "\n" /* multiline entry */
  "        if (strcmp(static_cast<const char *>(\"%%symbol%%\") + len, ptr) == 0) {\n"
  "            m_ptr_%%symbol%% =\n"
  "                sym<%%sym_type%%>\n"
  "                    (\"%%symbol%%\");\n"
  "            return (m_ptr_%%symbol%% != nullptr);\n"
  "        }",
  "",
  "        err_not_found();",
  "",
  "        return false;",
  "    }",
  "",
  "",
  "    /* check if ALL symbols were loaded */",
  "    bool all_symbols_loaded() const",
  "    {",
  "        if (true",
  "            && m_ptr_%%symbol%% != nullptr",
  "        ) {",
  "            return true;",
  "        }",
  "",
  "        return false;",
  "    }",
  "",
  "",
  "    /* check if NO symbols were loaded */",
  "    bool no_symbols_loaded() const",
  "    {",
  "        if (true",
  "            && m_ptr_%%symbol%% == nullptr",
  "        ) {",
  "            return true;",
  "        }",
  "",
  "        return false;",
  "    }",
  "",
  "",
  "    /* check if ANY symbol was loaded */",
  "    bool any_symbol_loaded() const",
  "    {",
  "        if (false",
  "            || m_ptr_%%symbol%% != nullptr",
  "        ) {",
  "            return true;",
  "        }",
  "",
  "        return false;",
  "    }",
  "",
  "",
  "    /* free library */",
  "    bool free()",
  "    {",
  "        clear_error();",
  "",
  "        if (!lib_loaded()) {",
  "            return true;",
  "        }",
  "",
  "        bool ret = free_lib();",
  "        save_error();",
  "",
  "        if (!ret) {",
  "            return false;",
  "        }",
  "",
  "        m_handle = nullptr;",
  "",
  "        m_ptr_%%symbol%% = nullptr;",
  "",
  "        return true;",
  "    }",
  "",
  "",
  "    /* whether to free the library in the class destructor */",
  "    void free_lib_in_dtor(bool b)",
  "    {",
  "        m_free_lib_in_dtor = b;",
  "    }",
  "",
  "",
  "    /* Create versioned library names for DLLs, dylibs and DSOs.",
  "     * make_libname(\"z\",1) for example will return \"libz-1.dll\", \"libz.1.dylib\" or \"libz.so.1\" */",
  "    static std::string make_libname(const std::string &name, unsigned int api)",
  "    {",
  "#ifdef _WIN32",
  "        return \"lib\" + name + '-' + std::to_string(api) + \".dll\";",
  "#elif defined(__APPLE__) && defined(__MACH__)",
  "        return \"lib\" + name + '.' + std::to_string(api) + \".dylib\";",
  "#elif defined(_AIX)",
  "        (UNUSED_REF) api;",
  "        return \"lib\" + name + \".a\";",
  "#elif defined(__ANDROID__)",
  "        (UNUSED_REF) api;",
  "        return \"lib\" + name + \".so\";",
  "#else",
  "        return \"lib\" + name + \".so.\" + std::to_string(api);",
  "#endif",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "    static std::wstring make_libname(const std::wstring &name, unsigned int api)",
  "    {",
  "        return L\"lib\" + name + L'-' + std::to_wstring(api) + L\".dll\";",
  "    }",
  "#endif //GDO_WINAPI",
  "",
  "",
  "#ifdef GDO_HAS_MSG_CB",
  "",
  "    /* Set a message callback function. */",
  "    static void message_callback(message_callback_t cb)",
  "    {",
  "        m_message_callback = cb;",
  "    }",
  "",
  "",
  "    /* Get a pointer to the message callback function. */",
  "    static message_callback_t message_callback()",
  "    {",
  "        return m_message_callback;",
  "    }",
  "",
  "#endif //GDO_HAS_MSG_CB",
  "",
  "",
  "#ifdef GDO_WINAPI",
  "",
  "    /* get path of loaded library */",
  "    std::string origin()",
  "    {",
  "        return get_origin_from_module_handle<char>();",
  "    }",
  "",
  "    std::wstring origin_w()",
  "    {",
  "        return get_origin_from_module_handle<wchar_t>();",
  "    }",
  "",
  "",
  "    /* retrieve the last error */",
  "    std::string error()",
  "    {",
  "        std::string buf = format_last_error_message<char>();",
  "",
  "        if (buf.empty()) {",
  "            buf = \"Last saved error code: \" + std::to_string(m_last_error);",
  "        }",
  "",
  "        if (!m_errmsg.empty()) {",
  "            buf.insert(0, \": \");",
  "            buf.insert(0, m_errmsg);",
  "        } else if (!m_werrmsg.empty()) {",
  "            buf.insert(0, \": \");",
  "            buf.insert(0, wstr_to_str(m_werrmsg));",
  "        }",
  "",
  "        return buf;",
  "    }",
  "",
  "    std::wstring error_w()",
  "    {",
  "        std::wstring buf = format_last_error_message<wchar_t>();",
  "",
  "        if (buf.empty()) {",
  "            buf = L\"Last saved error code: \" + std::to_wstring(m_last_error);",
  "        }",
  "",
  "        if (!m_werrmsg.empty()) {",
  "            buf.insert(0, L\": \");",
  "            buf.insert(0, m_werrmsg);",
  "        } else if (!m_errmsg.empty()) {",
  "            buf.insert(0, L\": \");",
  "            buf.insert(0, str_to_wstr(m_errmsg));",
  "        }",
  "",
  "        return buf;",
  "    }",
  "",
  "",
  "    /* get filename passed to load */",
  "    std::string filename()",
  "    {",
  "        if (m_filename.empty() && !m_wfilename.empty()) {",
  "            return wstr_to_str(m_wfilename);",
  "        }",
  "",
  "        return m_filename;",
  "    }",
  "",
  "    std::wstring filename_w()",
  "    {",
  "        if (m_wfilename.empty() && !m_filename.empty()) {",
  "            return str_to_wstr(m_filename);",
  "        }",
  "",
  "        return m_wfilename;",
  "    }",
  "",
  "",
  "#else",
  "/*********************************** dlfcn ***********************************/",
  "",
  "",
  "    /* get path of loaded library */",
  "    std::string origin()",
  "    {",
  "        clear_error();",
  "",
  "        if (!lib_loaded()) {",
  "            set_error_invalid_handle();",
  "            return {};",
  "        }",
  "",
  "#ifdef GDO_HAVE_DLINFO",
  "        struct link_map *lm = nullptr;",
  "        //%DNL%// std::cerr << \"DEBUG: using dlinfo()\" << std::endl;",
  "",
  "        int ret = ::dlinfo(m_handle, RTLD_DI_LINKMAP, reinterpret_cast<void *>(&lm));",
  "        save_error();",
  "",
  "        return (ret != -1 && lm->l_name) ? lm->l_name : \"\";",
  "#else",
  "        /* use dladdr() to get the library path from a symbol pointer */",
  "        std::string fname;",
  "        //%DNL%// std::cerr << \"DEBUG: using dladdr()\" << std::endl;",
  "",
  "        if (no_symbols_loaded()) {",
  "            m_errmsg = \"no symbols were loaded\";",
  "            return {};",
  "        }",
  "",
  "        auto get_fname = [&fname] (const void *ptr)",
  "        {",
  "            Dl_info info;",
  "",
  "            if (ptr && ::dladdr(ptr, &info) != 0 && info.dli_fname) {",
  "                fname = info.dli_fname;",
  "            }",
  "        };",
  "",
  "        get_fname(reinterpret_cast<void *>(m_ptr_%%symbol%%));\n" /* multiline entry */
  "        if (!fname.empty()) return fname;",
  "",
  "        m_errmsg = \"dladdr() failed to get library path\";",
  "",
  "        return {};",
  "#endif // !GDO_HAVE_DLINFO",
  "    }",
  "",
  "",
  "    /* retrieve the last error */",
  "    std::string error() const",
  "    {",
  "        return m_errmsg;",
  "    }",
  "",
  "",
  "    /* get filename passed to load */",
  "    std::string filename() const",
  "    {",
  "        return m_filename;",
  "    }",
  "",
  "#endif // !GDO_WINAPI",
  "",
  "};",
  "/******************************* end of class ********************************/",
  "",
  "} /* namespace gdo */",
  "",
  "",
  "",
  "/* aliases to raw function pointers */",
  "#if !defined(GDO_DISABLE_ALIASING) && !defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)",
  "#define %%func_symbol%% gdo::dl::m_ptr_%%func_symbol%%",
  "#endif",
  "",
  "/* aliases to raw object pointers */",
  "#if !defined(GDO_DISABLE_ALIASING)",
  "#define %%obj_symbol%% *gdo::dl::m_ptr_%%obj_symbol%%",
  "#endif",
  "",
  NULL
};

/* cxx.cpp */
static const char *cxx_body[] = {
  "#ifdef GDO_HAS_MSG_CB",
  "gdo::dl::message_callback_t gdo::dl::m_message_callback = nullptr;",
  "#endif",
  "gdo::dl::handle_t gdo::dl::m_handle = nullptr;",
  "",
  "%%type%% (*gdo::dl::m_ptr_%%func_symbol%%)(%%args%%) = nullptr;",
  "%%obj_type%% *gdo::dl::m_ptr_%%obj_symbol%% = nullptr;",
  "%PARAM_SKIP_REMOVE_BEGIN%",
  "",
  "",
  "",
  "/* helpers used by function wrappers */",
  "namespace gdo",
  "{",
  "    namespace helper",
  "    {",
  "#ifdef GDO_HAS_MSG_CB",
  "        static void error_exit(const char *msg)",
  "        {",
  "            auto cb = gdo::dl::message_callback();",
  "",
  "            if (cb) {",
  "                cb(msg);",
  "            } else {",
  "                std::cerr << msg << std::endl;",
  "            }",
  "",
  "            std::exit(1);",
  "        }",
  "#endif //GDO_HAS_MSG_CB",
  "    }",
  "}",
  "",
  "",
  "#if defined(GDO_WRAP_FUNCTIONS) && !defined(GDO_ENABLE_AUTOLOAD)",
  "",
  "",
  "/* function wrappers */",
  "\n" /* multiline entry */
  "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
  "    if (!gdo::dl::m_ptr_%%func_symbol%%) {\n"
  "        gdo::helper::error_exit(\"error: symbol `%%func_symbol%%' was not loaded\");\n"
  "    }\n"
  "    %%return%% gdo::dl::m_ptr_%%func_symbol%%(%%notype_args%%);\n"
  "}",
  "",
  "",
  "#elif defined(GDO_ENABLE_AUTOLOAD)",
  "",
  "",
  "namespace gdo",
  "{",
  "    namespace helper",
  "    {",
  "        static auto al = gdo::dl(GDO_DEFAULT_LIBA);",
  "",
  "        /* used internally by wrapper functions, symbol is never NULL */",
  "        static void quick_load(const char *symbol)",
  "        {",
  "            if (!al.load()) {",
  "                std::string msg = \"error loading library `\" GDO_DEFAULT_LIBA \"':\\n\" + al.error();",
  "                error_exit(msg.c_str());",
  "            }",
  "",
  "#ifdef GDO_DELAYLOAD",
  "            if (!al.load_symbol(symbol))",
  "#else",
  "            if (!al.load_all_symbols())",
  "#endif",
  "            {",
  "                std::string msg = \"error in auto-loading wrapper function `gdo::autoload::\";",
  "                msg += symbol + (\"': \" + al.error());",
  "                error_exit(msg.c_str());",
  "            }",
  "        }",
  "    }",
  "}",
  "",
  "",
  "/* autoload function wrappers */",
  "\n" /* multiline entry */
  "GDO_VISIBILITY %%type%% %%func_symbol%%(%%args%%) {\n"
  "    gdo::helper::quick_load(\"%%func_symbol%%\");\n"
  "    %%return%% gdo::dl::m_ptr_%%func_symbol%%(%%notype_args%%);\n"
  "}",
  "",
  "#endif //GDO_ENABLE_AUTOLOAD",
  "%PARAM_SKIP_END%",
  NULL
};

/* minimal.h */
static const char *min_c_header[] = {
  "/* whether to use WinAPI */",
  "#if defined(_WIN32) && !defined(GDO_USE_DLOPEN)",
  "# define GDO_WINAPI",
  "#endif",
  "",
  "#ifdef GDO_WINAPI",
  "# include <windows.h>",
  "# define GDO_LOAD_LIB(filename)       LoadLibraryExA(filename, NULL, 0)",
  "# define GDO_FREE_LIB(handle)         FreeLibrary(handle)",
  "/* cast to void* to avoid compiler warnings */",
  "# define GDO_GET_SYM(handle, symbol)  (void *)GetProcAddress(handle, symbol)",
  "#else",
  "# include <dlfcn.h>",
  "# define GDO_LOAD_LIB(filename)       dlopen(filename, RTLD_LAZY)",
  "# define GDO_FREE_LIB(handle)         dlclose(handle)",
  "# define GDO_GET_SYM(handle, symbol)  dlsym(handle, symbol)",
  "#endif",
  "",
  "#ifdef GDO_STATIC",
  "# define GDO_LINKAGE  static",
  "#else",
  "# define GDO_LINKAGE  /**/",
  "#endif",
  "",
  "",
  "/* Our library and symbols handle */",
  "typedef struct gdo_handle",
  "{",
  "#ifdef GDO_WINAPI",
  "    HMODULE handle;",
  "#else",
  "    void *handle;",
  "#endif",
  "",
  "    %%type%% (*%%func_symbol%%)(%%args%%);",
  "    %%obj_type%% *%%obj_symbol%%;",
  "",
  "} gdo_handle_t;",
  "",
  "GDO_LINKAGE gdo_handle_t gdo_hndl = {0};",
  "",
  "",
  "/* returns NULL on success and an error message if loading failed */",
  "GDO_LINKAGE const char *gdo_load_library_and_symbols(const char *filename)",
  "{",
  "    gdo_hndl.handle = GDO_LOAD_LIB(filename);",
  "",
  "    if (!gdo_hndl.handle) {",
  "        return \"failed to load library\";",
  "    }",
  "\n" /* multiline entry */
  "    /* %%symbol%% */\n"
  "    gdo_hndl.%%symbol%% = \n"
  "        (%%sym_type%%)\n"
  "            GDO_GET_SYM(gdo_hndl.handle, \"%%symbol%%\");\n"
  "    if (!gdo_hndl.%%symbol%%) {\n"
  "        GDO_FREE_LIB(gdo_hndl.handle);\n"
  "        return \"failed to load symbol: %%symbol%%\";\n"
  "    }",
  "",
  "    return NULL;",
  "}",
  "",
  "/* free library handle, no error checks */",
  "GDO_LINKAGE void gdo_free_library(void)",
  "{",
  "    GDO_FREE_LIB(gdo_hndl.handle);",
  "}",
  "",
  "",
  "#if !defined(GDO_NOALIAS)",
  "",
  "/* aliases to raw symbol pointers */",
  "#define %%func_symbol%%  gdo_hndl.%%func_symbol%%",
  "#define %%obj_symbol%%  *gdo_hndl.%%obj_symbol%%",
  "",
  "#endif // !GDO_NOALIAS",
  NULL
};

/* minimal_cxxeh.hpp */
static const char *min_cxx_header[] = {
  "/* whether to use WinAPI */",
  "#if defined(_WIN32) && !defined(GDO_USE_DLOPEN)",
  "# define GDO_WINAPI",
  "#endif",
  "",
  "#include <stdexcept>",
  "#include <string>",
  "#ifdef GDO_WINAPI",
  "# include <windows.h>",
  "#else",
  "# include <dlfcn.h>",
  "#endif",
  "",
  "",
  "/***",
  "",
  "A small C++ library loader that throws exceptions on error.",
  "",
  "Usage:",
  "",
  "    try {",
  "        gdo::load_library_and_symbols( LIBNAME(helloworld,0) );",
  "    }",
  "    catch (const gdo::LibraryError &e) {",
  "        std::cerr << \"error: failed to load library: \" << e.what() << std::endl;",
  "        return 1;",
  "    }",
  "    catch (const gdo::SymbolError &e) {",
  "        std::cerr << \"error: failed to load symbol: \" << e.what() << std::endl;",
  "        return 1;",
  "    }",
  "    catch (...) {",
  "        std::cerr << \"an unknown error has occurred\" << std::endl;",
  "        return 1;",
  "    }",
  "",
  "***/",
  "",
  "namespace gdo",
  "{",
  "    /* symbol pointers */",
  "    namespace ptr",
  "    {",
  "        %%type%% (*%%func_symbol%%)(%%args%%) = nullptr;",
  "        %%obj_type%% *%%obj_symbol%% = nullptr;",
  "    }",
  "",
  "#ifdef GDO_WINAPI",
  "",
  "    /* library handle */",
  "    HMODULE handle = nullptr;",
  "",
  "    /* load library */",
  "    inline HMODULE load_lib(const char *filename, int flags=0) {",
  "        return ::LoadLibraryExA(filename, nullptr, flags);",
  "    }",
  "",
  "    /* free library */",
  "    inline bool free_lib(HMODULE handle) {",
  "        return (::FreeLibrary(handle) == TRUE);",
  "    }",
  "",
  "    /* get symbol */",
  "    inline void *get_symbol(HMODULE handle, const char *symbol) {",
  "        /* cast to void* to avoid warnings such as [-Wcast-function-type] */",
  "        return reinterpret_cast<void *>(::GetProcAddress(handle, symbol));",
  "    }",
  "",
  "#else /* dlfcn */",
  "",
  "    /* library handle */",
  "    void *handle = nullptr;",
  "",
  "    /* load library */",
  "    inline void *load_lib(const char *filename, int flags=RTLD_LAZY) {",
  "        return ::dlopen(filename, flags);",
  "    }",
  "",
  "    /* free library */",
  "    inline bool free_lib(void *handle) {",
  "        return (::dlclose(handle) == 0);",
  "    }",
  "",
  "    /* get symbol */",
  "    inline void *get_symbol(void *handle, const char *symbol) {",
  "        return ::dlsym(handle, symbol);",
  "    }",
  "",
  "#endif //GDO_WINAPI",
  "",
  "",
  "    /* base error class */",
  "    class Error : public std::runtime_error",
  "    {",
  "        public:",
  "            Error(const std::string &message) : std::runtime_error(message) {}",
  "            virtual ~Error() {}",
  "    };",
  "",
  "    /* library loading error */",
  "    class LibraryError : public Error",
  "    {",
  "        public:",
  "            LibraryError(const std::string &message) : Error(message) {}",
  "            virtual ~LibraryError() {}",
  "    };",
  "",
  "    /* symbol loading error */",
  "    class SymbolError : public Error",
  "    {",
  "        public:",
  "            SymbolError(const std::string &message) : Error(message) {}",
  "            virtual ~SymbolError() {}",
  "    };",
  "",
  "",
  "    /* throw an exception on error */",
  "    void load_library_and_symbols(const char *filename) noexcept(false)",
  "    {",
  "        handle = load_lib(filename);",
  "",
  "        if (!handle) {",
  "            if (filename == NULL) {",
  "                filename = \"<NULL>\";",
  "            } else if (*filename == 0) {",
  "                filename = \"<EMPTY>\";",
  "            }",
  "",
  "            throw LibraryError(filename);",
  "        }",
  "\n" /* multiline entry */
  "        /* %%symbol%% */\n"
  "        ptr::%%symbol%% =\n"
  "            reinterpret_cast<%%sym_type%%>(\n"
  "                get_symbol(handle, \"%%symbol%%\"));\n"
  "        if (!ptr::%%symbol%%) {\n"
  "            free_lib(handle);\n"
  "            throw SymbolError(\"%%symbol%%\");\n"
  "        }",
  "    }",
  "",
  "}; /* end namespace */",
  "",
  "",
  "#if !defined(GDO_NOALIAS)",
  "",
  "/* aliases to raw symbol pointers */",
  "#define %%func_symbol%%  gdo::ptr::%%func_symbol%%",
  "#define %%obj_symbol%%  *gdo::ptr::%%obj_symbol%%",
  "",
  "#endif // !GDO_NOALIAS",
  NULL
};

#endif //_TEMPLATE_H_
